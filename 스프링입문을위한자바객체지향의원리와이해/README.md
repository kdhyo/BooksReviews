# 스프링 입문을 위한 자바 객체지향의 원리와 이해

1주차 감상평  
> JVM에 있는 메모리 중에서 클래스 중심으로 3 개의 메모리를 T 메모리로 표현하여  
그림을 통해 쉽게 표현하고, 설명해준다.  
  
2주차 감상평
> 흐름과 핵심을 짚어주고, 자칫 어려울 수도 있는 용어들을 아주 쉽게 풀어주어서  
초심자가 보기엔 좋지만, 용어에 대해서 더 알아보기 위해서 찾아봐야 할 것 같다.

## 새로운 기술이 나온 이유

- 기존 기술의 단점들을 보완하며 새로운 개념을 도입하여 더욱 개발자가 개발하기 편리하게 도와주기 위해

## JVM 3개의 메모리
---

### T 메모리 - 주요 메모리 3 종류  

- 스태틱(static) 영역

- 스택(stack) 영역

- 힙(heap) 영역

### 메모리 흐름  

- JVM이 올라가게 되면 java.lang 패키지가 스태틱 영역에 올라가게 된다.
- 클래스 처음 실행될 때 import된 패키지를 스태틱 영역에 올린다.
- 클래스 처음 실행될 때 해당 클래스를 스태틱 영역에 올린다.
- 메서드 실행 시 스택 영역에 올라가게 된다.(인수, 변수를 포함한다.)
- 객체의 인스턴스를 힙 영역에 올린다.
- 메서드가 종료되면 스택 영역에서 메소드 영역이 사라지게 된다.
- 힙 영역에 있는 인스턴스가 스택 영역의 메서드가 종료됨에 따라 연결하는 곳이 없게 되면 GC에 의해 제거대상이 된다.

### 변수는 어느 메모리에 올라가는 걸까?  

- 스태틱 영역 : 클래스 멤버 변수

- 스택 영역 : 지역 변수

- 힙 영역 : 객체 멤버 변수


## 상속
---

### 상속의 특성을 이해하는 세 문장  

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.

- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.

- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

### 상속 해석

- 상속 관계 : 하위 클래스 is a kind of 상위 클래스
- 해석 : 하위 클래스는 상위 클래스의 한 분류다.
- 예제 : 고래는 동물의 한 분류다.

### 인터페이스 해석

- 인터페이스 : 구현 클래스 is able to 인터페이스
- 해석 : 구현 클래스는 인터페이스할 수 있다.
- 예제 : 고래는 헤엄칠 수 있다.

    ### 예시

    - Serializable 인터페이스 : 직렬화할 수 있는
    - Cloneable 인터페이스 : 복제할 수 있는
    - Comparable 인터페이스 : 비교할 수 있는
    - Runnable 인터페이스 : 실행할 수 있는

### 상속 클래스 사용 시 메모리 구조

- 하위 클래스를 메모리에 할당할 시 상위 클래스도 메모리에 할당되게 된다. (Object 포함)

## 객체지향의 4가지 특성
---

### 캡!상추다

### 캡슐화

- 접근제한자를 통해 클래스의 상태 값을 어느 범위까지 오픈할 것인지를 정하여  
    상태 값을 감추는 것을 의미합니다.

### 상속

- 여러 클래스들의 공통된 개념을 하나로 묶어 상위 클래스로 정의하고  
    하위 클래스에서 상속을 통해 상위 클래스의 특성을 확장하거나 재사용할 수 있게 해줍니다.

### 추상화

- 공통의 속성이나 기능을 묶어 하나의 공통된 클래스를 정의하는 것을 말합니다.

### 다형성

- 오버로딩과 오버라이딩을 가능하게 해줌으로서 상위 클래스 타입을 선언하더라도  
    하위 클래스 타입의 인스턴스를 가지고 있다면  
    하위 클래스의 오버라이딩된 메소드를 사용할 수 있게 해줍니다.

### 접근자

private : 내부에서만 접근 가능

default : 같은 패키지 구조에서 접근 가능

protected : 같은 패키지 구조 / 상속된 클래스에서 접근 가능

public  : 모든 클래스에서 접근 가능

### Call By Value / Call By Reference

Call By Value 와 Call By Reference를 다르다고 이해하기 보다는  
기본 자료형 변수는 저장하고 있는 값을 그 값 자체로 판단하고,  
참조 변수는 저장하고 있는 값을 주소로 판단한다.  


## 자바가 확장한 객체 지향
---

### 생성자

- 개발자가 아무런 생성자도 많들지 않으면 자바는 인자가 없는 기본 생성자를 자동으로 만들어준다.
- 인자가 있는 생성자를 하나라도 만든다면 자바는 기본 생성자를 만들어 주지 않는다.

### static
> static 블록은 클래스가 제일 처음 사용될 때 단 한 번 실행된다.

- 클래스의 정적 속성을 사용할 때
- 클래스의 정적 메서드를 사용할 때
- 클래스의 인스턴스를 최초로 만들 때

### final

> 클래스
- 상속을 할 수 없다.

> 변수
- 변경이 불가능한 정적 상수가 된다.

> 메서드
- 오버라이딩을 할 수 없다.

### instanceof
- LSP (리스코프 치환 원칙) 을 어기는 코드에서 주로 나타나는 연산자이기에  
    냄새나는 코드가 아닌지, 즉 리팩터링의 대상이 아닌지 점검해봐야 한다.

### package
- 팀원과 패키지를 각각 맡아서 진행하여 네이밍 충돌을 방지할 수 있게 도와준다.

### interface
- public, static, final, abstract 를 자동으로 붙여준다.

### 객체 맴버 메서드
- 객체가 100개를 만들 때 똑같은 멤버 메서드를 힙 영역에 100개를 만드는 것은 심각한 메모리 낭비다.
- JVM에서는 지능적으로 객체 멤버 메서드를 스태틱 영역에 단 하나만 보유한다.
- 인수로 THIS 객체 참조 변수를 넘겨서 실행한다.

## 객체 지향 설계 5원칙 - SOLID
---

> 응집도를 높이고 결합도를 낮추어 객체 지향 프로그램을 올바르게 설계할 수 있도록 도와주는 원칙

- **SRP (Single Responsibility Principle) : 단일 책임 원칙**
    - 어떤 클래스를 변경해야 하는 이유는 오직 하나뿐이어야 한다.
    - 클래스, 메소드, 변수 모든 곳에서 하나의 책임만을 가지고 있는지 확인해보자.
- **OCP (Open Closed Principle) : 개방 폐쇄 원칙**
    - 자신의 확장에는 열려있고, 변경에는 닫혀 있어야 한다.
    - 인터페이스 등을 활용해 확장에는 열려 있지만, 수정 시 모든 곳을 수정할 수 있도록 변경에는 닫혀 있어야 한다.
    - 객체 지향 프로그래밍의 가장 큰 장점인 유연성, 재사용성, 유지보수성 등을 얻을 수 있게 된다.
- **LSP (Liskov Substitution Principle) : 리스코프 치환 원칙**
    - 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다.
    - 하위 클래스 is a ind of 상위 클래스 - 하위 분류는 상위 분류의 한 종류다.
    - 구현 클래스 is able to 인터페이스 - 구현 분류는 인터페이스할 수 있어야 한다.
    - 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다.
- **ISP (Interface Segregation Principle) : 인터페이스 분리 원칙**
    - 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.
    - 상위 클래스는 풍부할수록 좋고, 인터페이스는 작을수록 좋다.
    - 인터페이스는 “~ 할 수 있는” 이라는 기준으로 만드는 것이 정석이다.
- **DIP (Dependency Inversion Principle) : 의존 역전 원칙**
    - 고차원 모듈은 저차원 모듈에 의존하면 안 된다.
        - 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
    - 추상화된 것은 구체적인 것에 의존하면 안 된다.
        - 구체적인 것이 추상화된 것에 의존해야 한다.
    - 자주 변경되는 구체 클래스에 의존하지 마라.
    - 인터페이스 등에 의존하여 구현 클래스의 의존도를 줄이거나 없애는 것이 가장 좋다.
        - 자신보다 변하기 쉬운 것에 의존하지 말자.

### SoC
- 관심사 분리 (Separation Of Concerns)
    - 관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모으고,  
        관심이 다른 것은 가능한 한 따로 떨어져서로 영향을 주지 않도록 분리하라는 것.
    - SoC를 적용하면 자연스럽게 SOLID 원칙에 도달하게 된다.
    

## 스프링이 사랑한 디자인 패턴
---

### 스프링 프레임워크를 설명하는 공식적인 정의
- 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 **경량급 애플리케이션 프레임워크**
- **OOP 프레임워크** 라고 부를 수도 있음.

## 어댑터 패턴 (Adapter Pattern)
“호출당하는 쪽의 메서드를 호출하는 쪽의 코드에 대응하도록 중간에 변환기를 통해 호출하는 패턴”

- 개방 폐쇄 원칙 (OCP)를 활용한 설계로 볼 수 있다.
- Repository ↔ Service 관계?
- 객체를 속성으로 만들어서 참조하는 디자인 패턴

## 프록시 패턴 (Proxy Pattern)
“제어 흐름을 조정하기 위한 목적으로 중간에 대리자를 두는 패턴”

- 대리자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 대리자는 실제 서비스에 대한 참조 변수를 갖는다. (합성)
- 대리자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고 그 값을 클라이언트에게 돌려준다.
- 대리자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.
- 실제 서비스 메서드의 반환 값에 가감하지 않고, 앞뒤로 로직을 추가할 수 있게 해준다.
- 개방 폐쇄 원칙 (OCP) / 의존역전 원칙 (DIP) 이 적용된 설계 패턴

## 데코레이터 패턴 (Decorator Pattern)
“메서드 호출의 반환 값에 변화를 주기 위해 중간에 장식자를 두는 패턴”

- 프록시 패턴과 거의 유사한 패턴이다.
- 다른 점은 프록시는 반환 값을 유지하고, 데코레이터는 반환 값에 더한다.
- 장식자는 실제 서비스와 같은 이름의 메서드를 구현한다. 이때 인터페이스를 사용한다.
- 장식자는 실제 서비스에 대한 참조 변수를 갖는다. (합성)
- 장식자는 실제 서비스의 같은 이름을 가진 메서드를 호출하고, 그 반환값에 장식을 더해 클라이언트에게 돌려준다.
- 장식자는 실제 서비스의 메서드 호출 전후에 별도의 로직을 수행할 수도 있다.
- 개방 폐쇄 원칙 (OCP) / 의존 역전 원칙 (DIP) 이 적용된 설계 패턴

## 싱글턴 패턴 (Singleton Pettern)
“클래스의 인스턴스, 즉 객체를 하나만 만들어 사용하는 패턴”

- 스프링의 싱글턴 빈에 적용한 패턴
- private 생성자를 갖는다.
- 단일 객체 참조 변수를 정적 속성으로 갖는다.
- 단일 객체 참조 변수가 참조하는 단일 객체를 반환하는 getInstance() 정적 메서드를 갖는다.
- 단일 객체는 쓰기 가능한 속성을 갖지 않는 것이 정석이다.

## 템플릿 메서드 패턴 (Template Method Pattern)
“상위 클래스의 견본 메서드에서 하위 클래스가 오버라이딩한 메서드를 호출하는 패턴”

| 템플릿 메서드 패턴의 구성 요소 | 상위 클래스 - Animal | 하위 클래스 - Dog / Cat |
| --- | --- | --- |
| 템플릿 메서드 <br> 공통 로직을 수행, 로직 중에 하위 클래스에서 <br> 오버라이딩한 추상 메서드 / 훅 메서드를 호출 | playWithOwner() |  |
| 템플릿 메서드에서 호출하는 추상 메서드 <br> 하위 클래스가 반드시 오버라이딩 해야 한다. | play() | 오버라이딩 필수 |
| 템플릿 메서드에서 호출하는 훅(Hook, 갈고리) 메서드 <br> 하위 클래스가 선택적으로 오버라이딩 한다. | runSomething() | 오버라이딩 선택 |
|  |  |  |
- 의존 역전 원칙 (DIP) 을 활용
- 추상 클래스 공통 메서드 내에서 추상 메서드를 호출하는 방식

## 팩터리 메서드 패턴 (Factory Method Pattern)
“오버라이드된 메서드가 객체를 반환하는 패턴”

- 하위 클래스에서 팩터리 메서드를 오버라이딩해서 객체를 반환하게 하는 것을 의미한다.

## 전략 패턴 (Strategy Pattern)
“클라이언트가 전략을 생성해 전략을 실행할 컨텍스트에 주입하는 패턴”

- 디자인 패턴의 꽃
- 전략 메서드를 가진 전략 객체
- 전략 객체를 사용하는 컨텍스트 (전략 객체의 사용자 / 소비자)
- 전략 객체를 생성해 컨텍스트에 주입하는 클라이언트 (제 3자, 전략 객체의 공급자)
- 개방 폐쇄 원칙 (OCP) / 의존 역전 원칙 (DIP) 이 적용된 설계 패턴

## 템플릿 콜백 패턴 (Template Callback Pattern - 견본/회신 패턴)
“전략을 익명 내부 클래스로 구현한 전략 패턴”

- 전략 패턴에서는 클래스를 주입해주었다면, 이 패턴은 익명 내부 클래스로 구현
- 스프링 DI에서 활용 중
- 리팩터링된 템플릿 콜백 패턴은 템플릿을 공통 로직을 내부로 넣어서 사용한다.
- 개방 폐쇄 원칙 (OCP) / 의존 역전 원칙 (DIP) 이 적용된 설계 패턴

## 스프링이 사랑한 다른 패턴들
- 프론트 컨트롤러 패턴 (Front Controller Pattern)
- MVC 패턴 (Model - View - Controller)