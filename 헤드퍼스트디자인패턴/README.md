# 헤드퍼스트 디자인패턴 개정판

## 객체지향 기초
- 추상화
- 캡슐화
- 다형성
- 상속

## 디자인 원칙 - **객체지향 원칙**
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.  
> 바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는  
> 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.

> 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

> 상속보다는 구성을 활용한다.

> 상호작용하는 객체 사이에는 가능하면 `느슨한 결합`을 사용해야 한다.  
> 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도  
> 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있습니다.  
> 객체 사이의 상호의존성을 최소화할 수 있기 때문이죠.

> OCP (Open-Closed Principle)  
> 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

> DIP (Dependency Inversion Principle) - 의존 역전 원칙  
> 추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.

> 최소 지식 원칙(Principle of Least Knowledge) or 디미터 법칙(Law of Demeter)  
> 진짜 절친에게만 이야기해야 한다.

> SRP (Single Responsibility Principle) - 단일 책임 원칙  
> 어떤 클래스가 바뀌는 이유는 하나뿐이어야 한다.
  

## 1장. 디자인패턴 소개와 전략 패턴

### 객체지향 패턴 - 전략패턴
> 전략패턴이란 알고리즘군을 정의하고 캡슐화하여 각각의 알고리즘군을 수정해서 쓸 수 있게 해줍니다.  
> 전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

### 디자인 원칙
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.  
> 바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는  
> 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.

> 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

> 상속보다는 구성을 활용한다.

### 핵심정리
- 객체지향 기초 지식만 가지고는 훌륭한 객체지향 디자이너가 될 수 없습니다.
- 훌륭한 객체지향 디자인이라면 재사용성, 확장성, 관리용이성을 갖출 줄 알아야 합니다.
- 패턴은 훌륭한 객체지향 디자인 품질을 갖추고 있는 시스템을 만드는 방법을 제공합니다.
- 패턴은 검증받은 객체지향 경험의 산물입니다.
- 패턴이 코드를 바로 제공하는 것은 아닙니다. 디자인 문제의 보편적인 해법을 제공하죠.  
  특정 애플리케이션에 패턴을 적용하는 일은 여러분이 해야 합니다.
- 패턴은 발명되는 것이 아니라 발견되는 것입니다.
- 대부분의 패턴과 원칙은 소프트웨어의 변경 문제와 연관되어 있습니다.
- 대부분의 패턴은 시스템의 일부분을 나머지 부분과 무관하게 변경하는 방법을 제공합니다.
- 많은 경우에 시스템에서 바뀌는 부분을 골라내서 캡슐화해야 합니다.
- 패턴은 다른 개발자와의 의사소통을 극대화하는 전문 용어 역할을 합니다.
  
## 2장. 옵저버 패턴
> 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게  
> 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다.

### 디자인 원칙
> 상호작용하는 객체 사이에는 가능하면 `느슨한 결합`을 사용해야 한다.  
> 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도  
> 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있습니다.  
> 객체 사이의 상호의존성을 최소화할 수 있기 때문이죠.

### 핵심정리
- 옵저버 패턴은 객체들 사이에 일대다 관계를 정의합니다.
- 주제는 동일한 인터페이스를 써서 옵저버에게 연락을 합니다.
- Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있습니다.
- 주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 전혀 모릅니다.  
  따라서 이들 사이의 결합은 느슨한 결합입니다.
- 옵저버 패턴을 사용하면 주제가 데이터를 보내거나(푸쉬) 옵저버가 데이터를 가져올(풀) 수 있습니다.  
  일반적으로 풀 방식이 더 '옳은' 방식이라고 간주합니다.
- RxJava, 자바빈, RMI 외에 코코아나 스위프트, 자바스크립트와 같은 다른 언어의 프레임워크에서도 많이 사용됩니다.
- 옵저버 패턴은 여러 개의 주제와 메시지 유형이 있는 복잡한 상황에서 사용하는 출판-구독 패턴과 친척입니다.
- 옵저버 패턴은 자주 쓰이는 패턴으로 모델-뷰-컨트롤러를 배울 때 다시 만날 수 있습니다.

### 디자인 원칙 경시대회

- 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
> 옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식입니다.  
> 옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있습니다.  
> 나중에 바뀔 것을 대비해 두면 편하게 작업할 수 있습니다.

- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
> 주제와 옵저버에서 모두 인터페이스를 사용했습니다.  
> 주제는 Subject 인터페이스로 Observer 인터페이스를 구현하는 객체들의 등록과  
> 탈퇴를 관리하고, 그런 객체들에게 연락을 돌립니다.  
> 이러면 지금까지 우리가 봐 왔던 것처럼 느슨한 결합을 만들 수 있습니다.

- 상속보다는 구성을 활용한다.
> 옵저버 패턴에서는 구성을 활용해서 옵저버들을 관리합니다.  
> 주제와 옵저버 사이의 관게는 상속이 아니라 구성으로 이루어지니까요.  
> 게다가 실행 중에 구성되는 방식을 사용하니까 더할 나위 없이 좋겠죠.

## 3장. 데코레이터 패턴
> 데코레이터 패턴(Decorator Pattern)으로 객체에 추가 요소를 동적으로 더할 수 있습니다.  
> 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다.

### 디자인 원칙
> OCP (Open-Closed Principle)  
> 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

### 핵심정리
- 디자인의 유연성 면에서 보면 상속으로 확장하는 일은 별로 좋은 선택이 아닙니다.
- 기존 코드 수정 없이 행동을 확장해야 하는 상황도 있습니다.
- 구성과 위임으로 실행 중에 새로운 행동을 추가할 수 있습니다.
- 상속 대신 데코레이터 패턴으로 행동을 확장할 수 있습니다.
- 데코레이터 패턴은 구상 구성 요소를 감싸 주는 데코레이터를 사용합니다.
- 데코레이터 클래쓰의 형식은 그 클래스가 감싸는 클래스 형식을 반영합니다.
  (상속이나 인터페이스 구현으로 자신이 감쌀 클래스와 같은 형식을 가집니다.)
- 데코레이터는 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장합니다.
- 구성 요소를 감싸는 데코레이터의 개수에는 제한이 없습니다.
- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없습니다.
  클라이언트가 구성 요소의 구체적인 형식에 의존하는 경우는 예외입니다.
- 데코레이터 패턴을 사용하면 자잘한 객체가 매우 많이 추가될 수 있고, 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해집니다.
  
## 4장. 팩토리 패턴

### 팩토리 메서드 패턴
> 객체를 생성할 때 필요한 인스턴스를 만듭니다.  
> 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정합니다.  
> 팩토리 메서드를 사용하면 인스턴스 만드는 일을 서브클래스에 맡길 수 있습니다.

### 추상 팩토리 패턴
> 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공합니다.  
> 구상 클래스는 서브클래스에서 만듭니다.

### 디자인 원칙
> DIP (Dependency Inversion Principle) - 의존 역전 원칙  
> 추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.

### 핵심정리
- 팩토리를 쓰면 객체 생성을 캡슐화할 수 있습니다.  
- 간단한 팩토리는 엄밀하게 말해서 디자인 패턴은 아니지만,  
  클라이언트와 구상 클래스를 분리하는 간단한 기법으로 활용할 수 있습니다.
- 팩토리 메소드 패턴은 상속을 활용합니다. 객체 생성을 서브클래스에게 맡기죠.  
  서브클래스는 팩토리 메소드를 구현해서 객체를 생성합니다.
- 추상 팩토리 패턴은 객체 구성을 활용합니다.  
  팩토리 인터페이스에서 선언한 메소드에서 객체 생성이 구현되죠.
- 모든 팩토리 패턴은 애플리케이션의 구상 클래스 의존성을 줄여줌을써 느슨한 결합을 도와줍니다.
- 팩토리 메소드 패턴은 특정 클래스에서 인스턴스를 만드는 일을 서브클래스에게 넘깁니다.
- 추상 팩토리 패턴은 구상 클래스에 직접 의존하지 않고도 서로 관련된 객체로 이루어진 제품군을 만드는 용도로 쓰입니다.
- 의존성 역전 원칙을 따르면 구상 형식 의존을 피하고 추상화를 지향할 수 있습니다.
- 팩토리는 구상 클래스가 아닌 추상 클래스와 인터페이스에 맞춰서 코딩할 수 있게 해 주는 강력한 기법입니다.

## 5장. 싱글톤 패턴
> 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공합니다.

### 핵심정리
- 어떤 클래스에 싱글턴 패턴을 적용하면 그 클래스의 인스턴스가 1개만 있도록 할 수 있습니다.
- 싱글턴 패턴을 사용하면 하나뿐인 인스턴스를 어디서든지 접근할 수 있도록 할 수 있습니다.
- 자바에서 싱글턴 패턴을 구현할 때는 private 생성자와 정적 메소드, 정적 변수를 사용합니다.
- 멀티 스레드를 사용하는 애플리케이션에서는 속도와 자원 문제를 파악해 보고 적절한 구현법을 사용해야 합니다.  
  (사실 모든 애플리케이션에서 멀티스레딩을 쓸 수 있다고 생각해야 합니다.)
- DCL을 써서 구현하면 자바 5이전에 나온 버전에서는 스레드 관련 문제가 생길 수 있습니다. 주의하세요.
- 클래스 로더가 여러 개 있으면 싱글턴이 제대로 작동하지 않고, 여러 개의 인스턴스가 생길 수 있습니다.
- 자바의 enum을 쓰면 간단하게 싱글턴을 구현할 수 있습니다.

## 6장. 커맨드 패턴
> 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있습니다.  
> 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있습니다.

### 핵심정리
- 커맨드 패턴을 사용하면 요청하는 객체와 요청을 수행하는 객체를 분리할 수 있습니다.
- 이렇게 분리하는 과정의 중심에는 커맨드 객체가 있으며, 이 객체가 행동이 들어있는 리시버를 캡슐화합니다.
- 인보커는 무언가 요청할 때 커맨드 객체의 execute() 메소드를 호출하면 됩니다. execute() 메소드는 리시버에 있는 행동을 호출합니다.
- 커맨드는 인보커를 매개변수화할 수 있습니다. 실행 중에 동적으로 매개변수화를 설정할 수도 있습니다.
- execute() 메소드가 마지막으로 호출되기 전의 상태로 되돌리는 작업 취소 메소드를 구현하면 커맨드 패턴으로 작업 취소 기능을 구현할 수 있습니다.
- 매크로 커맨드는 커맨드를 확장해서 여러 개의 커맨드를 한 번에 호출할 수 있게 해 주는 가장 간편한 방법입니다.  
  매크로 커맨드로도 어렵지 않게 작업 취소 기능을 구현할 수 있습니다.
- 프로그래밍을 하다 보면 요청을 스스로 처리하는 '스마트'커맨드 객체를 사용하는 경우도 종종 있습니다.
- 커맨드 패턴을 활용해서 로그 및 트랜잭션 시스템을 구현할 수 있습니다.

## 7장. 어댑터 패턴과 퍼사드 패턴

### 어댑터 패턴
> 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환합니다.  
> 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도와줍니다.

### 퍼사드 패턴
> 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶어 줍니다.  
> 또한 고수준 인터페이스도 정의하므로 서브시스템을 더 편리하게 사용할 수 있습니다.

### 디자인 원칙
> 최소 지식 원칙(Principle of Least Knowledge) or 디미터 법칙(Law of Demeter)  
> 진짜 절친에게만 이야기해야 한다.

### 핵심정리
- 기존 클래스를 사용하려고 하는데 인터페이스가 맞지 않으면 어댑터를 쓰면 됩니다.
- 큰 인터페이스와 여러 인터페이스를 단순하게 바꾸거나 통합해야 하면 퍼사드를 쓰면 됩니다.
- 어댑터는 인터페이스를 클라이언트에서 원하는 인터페이스로 바꾸는 역할을 합니다.
- 퍼사드는 클라이언트를 복잡한 서브시스템과 분리하는 역할을 합니다.
- 어댑터를 구현할 때는 타깃 인터페이스의 크기와 구조에 따라 코딩해야 할 분량이 결정됩니다.
- 퍼사드 패턴에서는 서브시스템으로 퍼사드를 만들고 진짜 작업은 서브클래스에 맡깁니다.
- 어댑터 패턴에는 객체 어댑터 패턴과 클래스 어댑터 패턴이 있습니다. 클래스 어댑터를 쓰려면 다중 상속이 가능해야 합니다.
- 한 서브시스템에 퍼사드를 여러 개 만들어도 됩니다.
- 어댑터는 객체를 감싸서 인터페이스를 바꾸는 용도로, 데코레이터는 객체를 감싸서 새로운 행동을 추가하는 용도로, 퍼사드는 일련의 객체를 감싸서 단순하게 만드는 용도로 쓰입니다.

## 8장. 템플릿 메소드 패턴
> 알고리즘의 골격을 정의합니다.  
> 템플릿 메소드를 사용하면 알고리즘의 일부 단계를 서브 클래스에서 구현할 수 있으며,  
> 알고리즘의 구조는 그대로 유지하면서 알고리즘의 특정 단계를 서브클래스에서 재정의할 수도 있습니다.

### 디자인 원칙
> 할리우드 원칙(Hollywood Principle)  
> 먼저 연락하지 마세요. 저희가 연락 드리겠습니다.

### 핵심정리
- 템플릿 메소드는 알고리즘의 단계를 정의하며 일부 단계를 서브 클래스에서 구현하도록 할 수 있습니다.
- 템플릿 메소드 패턴은 코드 재사용에 큰 도움이 됩니다.
- 템플릿 메소드가 들어있는 추상 클래스는 구상 메소드, 추상 메소드, 후크를 정의할 수 있습니다.
- 추상 메소드는 서브클래스에서 구현합니다.
- 후크는 추상 클래스에 들어있는 메소드로 아무 일도 하지 않거나 기본 행동만을 정의합니다.  
  서브 클래스에서 후크를 오버라이드 할 수 있습니다.
- 할리우드 원칙에 의하면, 저수준 모듈을 언제 어떻게 호출할지는 고수준 모듈에서 결정하는 것이 좋습니다.
- 템플릿 메소드 패턴은 실전에 서도 꽤 자주 쓰이지만 반드시 '교과서적인' 방식으로 적용되진 않습니다.
- 전략패턴과 템플릿 메소드 패턴은 모두 알고리즘을 캡슐화하는 패턴이지만 전략 패턴은 구성을, 템플릿 메소드 패턴은 상속을 사용합니다.
- 팩토리 메소드 패턴은 특화된 템플릿 메소드 패턴입니다.

## 9장. 반복자 패턴과 컴포지트 패턴

### 반복자 패턴
> 컬렉션의 구현 방법을 노출하지 않으면서 집합체 내의 모든 항목에 접근하는 방법을 제공합니다.

### 컴포지트 패턴
> 객체를 트리구조로 구성해서 부분-전체 계층구조를 구현합니다.  
> 컴포지트 패턴을 사용하면 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있습니다.

### 디자인 원칙
> SRP (Single Responsibility Principle) - 단일 책임 원칙  
> 어떤 클래스가 바뀌는 이유는 하나뿐이어야 한다.

### 핵심정리
- 반복자를 사용하면 내부 구조를 드러내지 않으면서도 클라이언트가 컬렉션 안에 들어있는 모든 원소에 접근하도록 할 수 있습니다.
- 반복자 패턴을 사용하면 집합체를 대상으로 하는 반복 작업을 별도의 객체로 캡슐화할 수 있습니다.
- 반복자 패턴을 사용하면 컬랙션에 있는 모든 데이터를 대상으로 반복 작업을 하는 역할을 컬렉션에서 분리할 수 있습니다.
- 반복자 패턴을 쓰면 반복 작업에 똑같은 인터페이스를 적용할 수 있으므로 집합체에 있는 객체를 활용하는 코드를 만들 때 다형성을 활용할 수 있습니다.
- 한 클래스에는 될 수 있으면 한 가지 역할만 부여하는 것이 좋습니다.
- 컴포지트 패턴은 개별 객체와 복합 객체를 모두 담아 둘 수 있는 구조를 제공합니다.
- 컴포지트 패턴을 사용하면 클라이언트가 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있습니다.
- 복합 구조에 들어있는 것을 구성요소라고 부릅니다. 구성 요소에는 복합 객체와 잎 객체가 있습니다.
- 컴포지트 패턴을 적용할 때는 여러 가지 장단점을 고려해야 합니다. 상황에 따라 투명성과 안정성 사이에서 적절한 균형을 찾아야 합니다.

## 10장. 상태 패턴

### 상태 패턴
> 내부 상태가 바뀜에 따라 객체의 행동이 바뀔 수 있도록 해 줍니다.  
> 마치 객체의 클래스가 바뀌는 것 같은 결과를 얻을 수 있습니다.

### 핵심정리
- 상태 패턴을 사용하면 내부 상태를 바탕으로 여러 가지 서로 다른 행동을 사용할 수 있습니다.
- 상태 패턴을 사용하면 프로시저형 상태 기계를 쓸 때와는 달리 각 상태를 클래스로 표현합니다.
- Context 객체는 현재 상태에게 행동을 위임합니다.
- 각 상태를 클래스로 캡슐화해서 나중에 변경해야 하는 내용을 국지화할 수 있습니다.
- 상태 패턴과 전략 패턴의 클래스 다이어그램은 똑같지만 그 용도는 다릅니다.
- 전략 패턴에서 Context 클래스를 만들 때 행동과 알고리즘을 설정합니다.
- 상태 패턴을 사용하면 Context의 내부 상태가 바뀜에 따라 객체가 알아서 행동을 바꿀 수 있도록 할 수 있습니다.
- 상태 전환은 State 클래스로 제어할 수도 있고, Context 클래스로 제어할 수도 있습니다.
- 상태 패턴을 쓰면 디자인에 필요한 클래스의 개수가 늘어납니다.
- State 클래스를 여러 Context 객체의 인스턴스에서 공유하도록 디자인할 수도 있습니다.

## 11장. 프록시 패턴

> 특정 객체로의 접근을 제어하는 대리인(특정 객체를 대변하는 객체)을 제공합니다.

### 핵심정리
- 프록시 패턴을 사용하면 어떤 객체의 대리인을 내세워서 클라이언트의 접근을 제어할 수 있습니다. 접근을 관리하는 방법에는 여러 가지가 있습니다.
- 원격 프록시는 클라이언트와 원격 객체 사이의 데이터 전달을 관리해 줍니다.
- 가상 프록시는 인스턴스를 만드는 데 많은 비용이 드는 객체로의 접근을 제어합니다.
- 보호 프록시는 호출하는 쪽의 권한에 따라서 객체에 있는 메소드로의 접근을 제어합니다.
- 그 외에도 캐싱 프록시, 동기화 프록시, 방화벽 프록시, 지연 복사 프록시와 같이 다양한 변형된 프록시 패턴이 있습니다.
- 프록시 패턴의 구조는 데코레이터 패턴의 구조와 비슷하지만 그 용도는 다릅니다.
- 데코레이터 패턴은 객체에 행동을 추가하지만 프록시 패턴은 접근을 제어합니다.
- 자바에 내장된 프록시 지원 기능을 사용하면 동적 프록시 클래스를 만들어서 원하는 핸들러에서 호출을 처리하도록 할 수 있습니다.
- 다른 래퍼(Wrapper)를 쓸 때와 마찬가지로 프록시를쓰면 디자인에 포함되는 클래스와 객체의 수가 늘어납니다.

## 12장. 복합 패턴

> 2개 이상의 패턴을 결합해서 일반적으로 자주 등장하는 문제들의 해법을 제공합니다.

### 핵심정리
- 모델-뷰-컨트롤러(MVC는 옵저버, 전략, 컴포지트 패턴으로 이루어진 복합 패턴입니다.
- 모델은 옵저버 패턴을 사용해서 의존성을 없애면서도 옵저버들에게 자신의 상태가 변경되었음을 알릴 수 있습니다.
- 컨트롤러는 뷰의 전략 객체입니다. 뷰는 컨트롤러를 바꿔서 또 다른 행동을 할 수 있습니다.
- 뷰는 컴포지트 패턴을 사용해서 사용자 인터페이스를 구현합니다. 보통 패널이나 프레임, 버튼과 같은 중첩된 구성 요소로 이루어집니다.
- 모델, 뷰, 컨트롤러는 방금 말한 3가지 패턴으로 서로 느슨하게 결합되므로 깔끔하면서도 유연한 구현이 가능합니다.
- 새로운 모델을 기존의 뷰와 컨트롤러에 연결해서 쓸 때는 어댑터 패턴을 활용하면 됩니다.
- MVC는 웹에도 적용됩니다.
- 클라이언트-서버 애플리케이션 구조에 MVC를 적응시켜 주는 다양한 웹 MVC 프레임워크가 있습니다.

## 14장. 기타 패턴

### 브리지 패턴

#### 장점

- 구현과 인터페이스를 완전히 결합하지 않았기에 구현과 추상화 부분을 분리할 수 있습니다.
- 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있습니다.
- 추상화 부분을 구현한 구상 클래스가 바뀌어도 클라이언트에는 영향을 끼치지 않습니다.

#### 활용법과 단점

- 여러 플랫폼에서 사용해야 하는 그래픽스와 윈도우 처리 시스템에서 유용하게 쓰입니다.
- 인터페이스와 실제 구현할 부분을 서로 다른 방식으로 변경해야 할 때 유용하게 쓰입니다.
- 디자인이 복잡해진다는 단점이 있습니다.

### 빌더 패턴

#### 장점

- 복합 객체 생성 과정을 캡슐화합니다.
- 여러 단계와 다양한 절차를 거쳐 객체를 만들 수 있습니다. (팩토리 패턴은 한 단계에서 모든 걸 처리하죠).
- 제품의 내부 구조를 클라이언트로부터 보호할 수 있습니다.
- 클라이언트는 추상 인터페이스만 볼 수 있기에 제품을 구현한 코드를 쉽게 바꿀 수 있습니다.

#### 활용법과 단점

- 복합 객체 구조를 구축하는 용도로 많이 쓰입니다.
- 팩토리를 사용할 때 보다 객체를 만들 때 클라이언트에 관해 더 많이 알아야 합니다.

### 책임 연쇄 패턴

#### 장점

- 요청을 보낸 쪽과 받는 쪽을 분리할 수 있습니다.
- 객체는 사슬의 구조를 몰라도 되고 그 사슬에 들어있는 다른 객체의 직접적인 레퍼런스를 가질 필요도 없으므로 객체를 단순하게 만들 수 있습니다.
- 사슬에 들어가는 객체를 바꾸거나 순서를 바꿈으로써 역할을 동적으로 추가하거나 제거할 수 있습니다.

#### 활용법과 단점

- 윈도우 시스템에서 마우스 클릭과 키보드 이벤트를 처리할 때 흔히 쓰입니다.
- 요청이 반드시 수행된다는 보장이 없다는 단점이 있습니다. 사슬 끝까지 갔는데도 처리되지 않을 수 있죠 (사실 이런 특성이 장점이 될 수도 있긴 합니다).
- 실행 시에 과정을 살펴보거나 디버깅하기가 힘들다는 단점이 있습니다.

### 플라이웨이트 패턴

#### 장점

- 실행 시에 객체 인스턴스의 개수를 줄여서 메모리를 절약할 수 있습니다.
- 여러 '가상'객체의 상태를 한 곳에 모아 둘 수 있습니다.

#### 사용법과 단점

- 어떤 클래스의 인스턴스가 아주 많이 필요하지만 모두 똑같은 방식으로 제어해야 할 때 유용하게 쓰입니다.
- 일단 이 패턴을 써서 구현해 놓으면 특정 인스턴스만 다른 인스턴스와 다르게 행동하게 할 수 없다는 단점이 있습니다.

### 인터프리터 패턴

#### 장점

- 문법을 클래스로 표현해서 쉽게 언어를 구현할 수 있습니다.
- 문법이 클래스로 표현되므로 언어를 쉽게 변경하거나 확장할 수 있습니다.
- 클랫그 구조에 메소드만 추가하면 프로그램을 해석하는 기본 기능 외에 예쁘게 출력하는 기능이나 더 나은 프로그램 확인 기능 같은 새로운 기능을 추가할 수 있습니다.

#### 활용법과 단점

- 간단한 언어를 구현할 때 인터프리터 패턴이 유용하게 쓰입니다.
- 효율보다는 단순하고 간단하게 문법을 만드는 것이 더 중요한 경우에 유용합니다.
- 스크립트 언어와 프로그래밍 언어에서 모두 쓸 수 있습니다.
- 문법 규칙의 개수가 많아지면 아주 복잡해진다는 단점이 있습니다.  
  그럴 때는 파서나 컴파일러 생성기를 쓰는 편이 낫습니다.

### 메멘토 패턴

#### 장점

- 저장된 상태를 핵심 객체와는 다른 별도의 객체에 보관할 수 있어 안전합니다.
- 핵심 객체의 데이터를 계속해서 캡슐화된 상태로 유지할 수 있습니다.
- 복구 기능을 구현하기가 쉽습니다.

#### 활용법과 단점

- 메멘토 객체를 써서 상태를 저장합니다.
- 자바 시스템에서는 시스템의 상태를 저장할 때 직렬화를 사용하는 것이 좋습니다.
- 상태를 저장하고 복구하는 데 시간이 오래 걸릴 수 있다는 단점이 있습니다.

### 프로토타입 패턴

#### 장점

- 클라이언트는 새로운 인스턴스를 만드는 과정을 몰라도 됩니다.
- 클라이언트는 구체적인 형식을 몰라도 객체를 생성할 수 있습니다.
- 상황에 따라서 객체를 새로 생성하는 것보다 객체를 복사하는 것이 더 효율적일 수 있습니다.

#### 활용법과 단점

- 시스템에서 복잡한 클래스 계층구조에 파묻혀 있는 다양한 형식의 객체 인스턴스를 새로 만들어야 할 때 유용하게 써먹을 수 있습니다.
- 때때로 객체의 복사본을 만드는 일이 매우 복잡할 수도 있다는 단점이 있습니다.

### 비지터 패턴

#### 장점

- 구조를 변경하지 않으면서도 복합 객체 구조에 새로운 기능을 추가할 수 있습니다.
- 비교적 손쉽게 새로운 기능을 추가할 수 있습니다.
- 비지터가 수행하는 기능과 관련된 코드를 한 곳에 모아 둘 수 있습니다.

#### 단점
- 비지터를 사용하면 복합 클래스의 캡슐화가 깨집니다.
- 컬렉션 내의 모든 항목에 접근하는 트래버서가 있으므로 복합 구조를 변경하기가 더 어려워집니다.

