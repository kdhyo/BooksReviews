# 헤드퍼스트 디자인패턴 개정판

## 객체지향 기초
- 추상화
- 캡슐화
- 다형성
- 상속

## 디자인 원칙 - **객체지향 원칙**
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.  
> 바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는  
> 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.

> 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

> 상속보다는 구성을 활용한다.

> 상호작용하는 객체 사이에는 가능하면 `느슨한 결합`을 사용해야 한다.  
> 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도  
> 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있습니다.  
> 객체 사이의 상호의존성을 최소화할 수 있기 때문이죠.

> OCP (Open-Closed Principle)  
> 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

> DIP (Dependency Inversion Principle) - 의존 역전 원칙  
> 추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.
  

## 1장. 디자인패턴 소개와 전략 패턴

### 객체지향 패턴 - 전략패턴
> 전략패턴이란 알고리즘군을 정의하고 캡슐화하여 각각의 알고리즘군을 수정해서 쓸 수 있게 해줍니다.  
> 전략패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.

### 디자인 원칙
> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.  
> 바뀌는 부분은 따로 뽑아서 캡슐화한다. 그러면 나중에 바뀌지 않는 부분에는  
> 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있다.

> 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

> 상속보다는 구성을 활용한다.

### 핵심정리
- 객체지향 기초 지식만 가지고는 훌륭한 객체지향 디자이너가 될 수 없습니다.
- 훌륭한 객체지향 디자인이라면 재사용성, 확장성, 관리용이성을 갖출 줄 알아야 합니다.
- 패턴은 훌륭한 객체지향 디자인 품질을 갖추고 있는 시스템을 만드는 방법을 제공합니다.
- 패턴은 검증받은 객체지향 경험의 산물입니다.
- 패턴이 코드를 바로 제공하는 것은 아닙니다. 디자인 문제의 보편적인 해법을 제공하죠.  
  특정 애플리케이션에 패턴을 적용하는 일은 여러분이 해야 합니다.
- 패턴은 발명되는 것이 아니라 발견되는 것입니다.
- 대부분의 패턴과 원칙은 소프트웨어의 변경 문제와 연관되어 있습니다.
- 대부분의 패턴은 시스템의 일부분을 나머지 부분과 무관하게 변경하는 방법을 제공합니다.
- 많은 경우에 시스템에서 바뀌는 부분을 골라내서 캡슐화해야 합니다.
- 패턴은 다른 개발자와의 의사소통을 극대화하는 전문 용어 역할을 합니다.
  
## 2장. 옵저버 패턴
> 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게  
> 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의합니다.

### 디자인 원칙
> 상호작용하는 객체 사이에는 가능하면 `느슨한 결합`을 사용해야 한다.  
> 느슨하게 결합하는 디자인을 사용하면 변경 사항이 생겨도  
> 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있습니다.  
> 객체 사이의 상호의존성을 최소화할 수 있기 때문이죠.

### 핵심정리
- 옵저버 패턴은 객체들 사이에 일대다 관계를 정의합니다.
- 주제는 동일한 인터페이스를 써서 옵저버에게 연락을 합니다.
- Observer 인터페이스를 구현하기만 하면 어떤 구상 클래스의 옵저버라도 패턴에 참여할 수 있습니다.
- 주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 관해 전혀 모릅니다.  
  따라서 이들 사이의 결합은 느슨한 결합입니다.
- 옵저버 패턴을 사용하면 주제가 데이터를 보내거나(푸쉬) 옵저버가 데이터를 가져올(풀) 수 있습니다.  
  일반적으로 풀 방식이 더 '옳은' 방식이라고 간주합니다.
- RxJava, 자바빈, RMI 외에 코코아나 스위프트, 자바스크립트와 같은 다른 언어의 프레임워크에서도 많이 사용됩니다.
- 옵저버 패턴은 여러 개의 주제와 메시지 유형이 있는 복잡한 상황에서 사용하는 출판-구독 패턴과 친척입니다.
- 옵저버 패턴은 자주 쓰이는 패턴으로 모델-뷰-컨트롤러를 배울 때 다시 만날 수 있습니다.

### 디자인 원칙 경시대회

- 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분과 분리한다.
> 옵저버 패턴에서 변하는 것은 주제의 상태와 옵저버의 개수, 형식입니다.  
> 옵저버 패턴에서는 주제를 바꾸지 않고도 주제의 상태에 의존하는 객체들을 바꿀 수 있습니다.  
> 나중에 바뀔 것을 대비해 두면 편하게 작업할 수 있습니다.

- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
> 주제와 옵저버에서 모두 인터페이스를 사용했습니다.  
> 주제는 Subject 인터페이스로 Observer 인터페이스를 구현하는 객체들의 등록과  
> 탈퇴를 관리하고, 그런 객체들에게 연락을 돌립니다.  
> 이러면 지금까지 우리가 봐 왔던 것처럼 느슨한 결합을 만들 수 있습니다.

- 상속보다는 구성을 활용한다.
> 옵저버 패턴에서는 구성을 활용해서 옵저버들을 관리합니다.  
> 주제와 옵저버 사이의 관게는 상속이 아니라 구성으로 이루어지니까요.  
> 게다가 실행 중에 구성되는 방식을 사용하니까 더할 나위 없이 좋겠죠.

## 3장. 데코레이터 패턴
> 데코레이터 패턴(Decorator Pattern)으로 객체에 추가 요소를 동적으로 더할 수 있습니다.  
> 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다.

### 디자인 원칙
> OCP (Open-Closed Principle)  
> 클래스는 확장에는 열려 있어야 하지만, 변경에는 닫혀 있어야 한다.

### 핵심정리
- 디자인의 유연성 면에서 보면 상속으로 확장하는 일은 별로 좋은 선택이 아닙니다.
- 기존 코드 수정 없이 행동을 확장해야 하는 상황도 있습니다.
- 구성과 위임으로 실행 중에 새로운 행동을 추가할 수 있습니다.
- 상속 대신 데코레이터 패턴으로 행동을 확장할 수 있습니다.
- 데코레이터 패턴은 구상 구성 요소를 감싸 주는 데코레이터를 사용합니다.
- 데코레이터 클래쓰의 형식은 그 클래스가 감싸는 클래스 형식을 반영합니다.
  (상속이나 인터페이스 구현으로 자신이 감쌀 클래스와 같은 형식을 가집니다.)
- 데코레이터는 자기가 감싸고 있는 구성 요소의 메소드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장합니다.
- 구성 요소를 감싸는 데코레이터의 개수에는 제한이 없습니다.
- 구성 요소의 클라이언트는 데코레이터의 존재를 알 수 없습니다.
  클라이언트가 구성 요소의 구체적인 형식에 의존하는 경우는 예외입니다.
- 데코레이터 패턴을 사용하면 자잘한 객체가 매우 많이 추가될 수 있고, 데코레이터를 너무 많이 사용하면 코드가 필요 이상으로 복잡해집니다.
  
## 4장. 팩토리 패턴

### 팩토리 메서드 패턴
> 객체를 생성할 때 필요한 인스턴스를 만듭니다.  
> 어떤 클래스의 인스턴스를 만들지는 서브 클래스에서 결정합니다.  
> 팩토리 메서드를 사용하면 인스턴스 만드는 일을 서브클래스에 맡길 수 있습니다.

### 추상 팩토리 패턴
> 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이루어진 제품군을 생성하는 인터페이스를 제공합니다.  
> 구상 클래스는 서브클래스에서 만듭니다.

### 디자인 원칙
> DIP (Dependency Inversion Principle) - 의존 역전 원칙  
> 추상화된 것에 의존하게 만들고, 구상 클래스에 의존하지 않게 만든다.

### 핵심정리
- 팩토리를 쓰면 객체 생성을 캡슐화할 수 있습니다.  
- 간단한 팩토리는 엄밀하게 말해서 디자인 패턴은 아니지만,  
  클라이언트와 구상 클래스를 분리하는 간단한 기법으로 활용할 수 있습니다.
- 팩토리 메소드 패턴은 상속을 활용합니다. 객체 생성을 서브클래스에게 맡기죠.  
  서브클래스는 팩토리 메소드를 구현해서 객체를 생성합니다.
- 추상 팩토리 패턴은 객체 구성을 활용합니다.  
  팩토리 인터페이스에서 선언한 메소드에서 객체 생성이 구현되죠.
- 모든 팩토리 패턴은 애플리케이션의 구상 클래스 의존성을 줄여줌을써 느슨한 결합을 도와줍니다.
- 팩토리 메소드 패턴은 특정 클래스에서 인스턴스를 만드는 일을 서브클래스에게 넘깁니다.
- 추상 팩토리 패턴은 구상 클래스에 직접 의존하지 않고도 서로 관련된 객체로 이루어진 제품군을 만드는 용도로 쓰입니다.
- 의존성 역전 원칙을 따르면 구상 형식 의존을 피하고 추상화를 지향할 수 있습니다.
- 팩토리는 구상 클래스가 아닌 추상 클래스와 인터페이스에 맞춰서 코딩할 수 있게 해 주는 강력한 기법입니다.

## 5장. 싱글톤 패턴
> 클래스 인스턴스를 하나만 만들고, 그 인스턴스로의 전역 접근을 제공합니다.

### 핵심정리
- 어떤 클래스에 싱글턴 패턴을 적용하면 그 클래스의 인스턴스가 1개만 있도록 할 수 있습니다.
- 싱글턴 패턴을 사용하면 하나뿐인 인스턴스를 어디서든지 접근할 수 있도록 할 수 있습니다.
- 자바에서 싱글턴 패턴을 구현할 때는 private 생성자와 정적 메소드, 정적 변수를 사용합니다.
- 멀티 스레드를 사용하는 애플리케이션에서는 속도와 자원 문제를 파악해 보고 적절한 구현법을 사용해야 합니다.  
  (사실 모든 애플리케이션에서 멀티스레딩을 쓸 수 있다고 생각해야 합니다.)
- DCL을 써서 구현하면 자바 5이전에 나온 버전에서는 스레드 관련 문제가 생길 수 있습니다. 주의하세요.
- 클래스 로더가 여러 개 있으면 싱글턴이 제대로 작동하지 않고, 여러 개의 인스턴스가 생길 수 있습니다.
- 자바의 enum을 쓰면 간단하게 싱글턴을 구현할 수 있습니다.

## 6장. 커맨드 패턴
> 요청 내역을 객체로 캡슐화해서 객체를 서로 다른 요청 내역에 따라 매개변수화할 수 있습니다.  
> 이러면 요청을 큐에 저장하거나 로그로 기록하거나 작업 취소 기능을 사용할 수 있습니다.

### 핵심 정리
- 커맨드 패턴을 사용하면 요청하는 객체와 요청을 수행하는 객체를 분리할 수 있습니다.
- 이렇게 분리하는 과정의 중심에는 커맨드 객체가 있으며, 이 객체가 행동이 들어있는 리시버를 캡슐화합니다.
- 인보커는 무언가 요청할 때 커맨드 객체의 execute() 메소드를 호출하면 됩니다. execute() 메소드는 리시버에 있는 행동을 호출합니다.
- 커맨드는 인보커를 매개변수화할 수 있습니다. 실행 중에 동적으로 매개변수화를 설정할 수도 있습니다.
- execute() 메소드가 마지막으로 호출되기 전의 상태로 되돌리는 작업 취소 메소드를 구현하면 커맨드 패턴으로 작업 취소 기능을 구현할 수 있습니다.
- 매크로 커맨드는 커맨드를 확장해서 여러 개의 커맨드를 한 번에 호출할 수 있게 해 주는 가장 간편한 방법입니다.  
  매크로 커맨드로도 어렵지 않게 작업 취소 기능을 구현할 수 있습니다.
- 프로그래밍을 하다 보면 요청을 스스로 처리하는 '스마트'커맨드 객체를 사용하는 경우도 종종 있습니다.
- 커맨드 패턴을 활용해서 로그 및 트랜잭션 시스템을 구현할 수 있습니다.