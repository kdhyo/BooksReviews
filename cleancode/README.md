# 클린 코드(Clean Code)

# [노개북] Today I Read - 클린코드

### [- 22.01.21 TIL](#day-01)
### [- 22.01.22 TIL](#day-02)
### [- 22.01.23 TIL](#day-03)
### [- 22.01.24 TIL](#day-04)
### [- 22.01.25 TIL](#day-05)
### [- 22.01.26 TIL](#day-06)
### [- 22.01.27 TIL](#day-07)
### [- 22.01.28 TIL](#day-08)
### [- 22.01.29 TIL](#day-09)
### [- 22.01.30 TIL](#day-10)
### [- 22.01.31 TIL](#day-11)
</br>

### [- 22.02.01 TIL](#day-12)
### [- 22.02.02 TIL](#day-13)
### [- 22.02.03 TIL](#day-14)
### [- 22.02.04 TIL](#day-15)
### [- 22.02.05 TIL](#day-16)
### [- 22.02.06 TIL](#day-17)
### [- 22.02.07 TIL](#day-18)
### [- 22.02.08 TIL](#day-19)
### [- 22.02.09 TIL](#day-20)
### [- 22.02.10 TIL](#day-21)
</br>

# [클완스] Today I Read - 클린코드 완독 스터디
### [- 22.02.15 TIL](#day-22)
### [- 22.02.16 TIL](#day-23)


</br>

# 📘 추천사 & 들어가면서 | Foreword & Introduction
## **_Day 01_**
## TIL(2022.01.21) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 보이스카우트 단원들에게 야영장에 들어올 때보다 나갈 때 더 깨끗한 상태로 만들 의무가 있다면, 우리 개발자들에게는 체크아웃해 코드를 꺼낼 때보다 체크인해서 코드를 넣을 때 더 깨끗한 상태로 만들어야 할 의무가 있다.

> 사소한 곳에서 발휘하는 정직은 사소하지 않다.

> TPM(Total Productive Management) 5S원칙
1. 정리 또는 조직 : 적절한 명명법 등과 같은 방법을 사용해 무엇이 어디에 있는지 알아야 한다. 명명법이 중요하지 않다고 생각하는가? 이어지는 장을 읽어보기 바란다.   
2. 정돈 또는 단정함 : "물건마다 모두 제자리가 있다" 라는 속담이 있다. 코드는 누구나 예상하는 위치에 있어야 한다. 그렇지 않으면 다시 정돈해 누구나 예상하는 위치로 옮기기 바란다.   
3. 청소 또는 정리 : 작업 공간에서 배선이나 기름이나 부스러기나 쓰레기는 치운다. 과거 이력이나 미래 바람을 기억한 주석 혹은 주석으로 처리한 코드는 어떻게 처리하라고? 제거하기 바란다.   
4. 청결 또는 표준화 : 작업 공간을 청소하는 방식에 그룹이 동의한다. 그룹 내에서 일관적인 구현 스타일과 기법의 필요성을 책에서는 뭐라고 말할까? 표준은 어떻게 정할까? 직접 읽어보기 바란다.   
5. 생활화 또는 규율 : 관례를 따르고, 자기 작품을 자주 돌아보고, 기꺼이 변경하는 규율을 뜻한다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
'옮긴이 서문'부터 '작가 서문' 까지 이 책을 읽을 때에 마음가짐을 확실하게 잡아준다는 느낌을 받았다.  
> 옛날 옛적에 성문 종합 영어나 수학의 정석을 붙들고 공부했듯이, 밑줄을 쳐가며 공부하는 책이다. 코드를 하나하나 짚어가며 저자가 코드를 고쳐간 방식을 이해하고 납득해야 가치를 발휘하는 책이다.

> 비행기 안에서 심심풀이로 읽어보는 "기분 좋은" 책이 아니다. 열심히, 아주 열심히 독파해야 하는 책이다.   

예전에도 이 책을 도전 한 적이 있지만, 제대로 읽지 못하고 중간에서 멈추게 되었다.  
당시 나는 조금 더 'JAVA'와 'SPRING'에 집중해서 공부를 해서 회사 업무에 차질이 생기지 않는 것이 더 중요하였기 때문이다.   
이제는 이 책을 어느정도 읽을 시간도 생겼고, 마침 니꼬쌤이 주최하는 '노개북'에 참여할 기회도 얻게 되어서 이 기회를 살려서 한 달간 열심히 읽어 보아야겠다.   
니꼬쌤의 한 마디에서 말했듯 한 달간 완독을 하진 않겠지만 그 말의 뜻은 오늘 읽은 서문과 일치하는 말씀이었다. 하나하나 집중해서 읽어보도록 마음가짐을 잡게 되는 시작의 날이라 생각된다.

</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- DVCS
- 보이스카우트 규칙

</br>

---
### 👀 소감 3줄 요약
- 한 달간 빠짐 없이 읽도록 마음가짐을 잡을 수 있는 서문
- 깨끗한 코드를 위해 세세한 노력은 필수
- 완독을 목표로 하는 것이 아닌 하나하나 흡수하면서 읽는 것을 목표로

</br>
</br>

# 📘 1장 깨끗한 코드

## **_Day 02_**
## TIL(2022.01.22) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> - 코드는 요구사항을 상세히 표현하는 수단이니까!  
> - 회사가 망한 원인은 바로 나쁜 코드 탓이었다.  
> - 나중은 결코 오지 않는다.  
> - 나쁜 코드의 위험을 이해하지 못하는 관리자 말을 그대로 따르는 행동은 전문가 답지 못하다.

</br>

> '코드 감각'이 없는 프로그래머도 때로는 나쁜 모듈을 알아본다. 하지만 그것으로 끝이다.   
'코드 감각'이 있는 프로그래머는 나쁜 모듈을 보면 좋은 모듈로 개선할 방안을 떠올린다.   
'코드 감각'으로 최고 방안을 선택한 후 여기서 거기까지 이동하는 경로를 계획한다.   
다시 말해, 깨끗한 코드를 작성하는 프로그래머는 빈 캔퍼스 를 우아한 작품으로 바꿔가는 화가와 같다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
항상 빨리 결과물을 나타내야 된다는 생각으로 일단, 코드를 짜곤 했었던 때가 있었다.  
결국 몇 개월 뒤에 내가 봐도 내 코드를 이해하는 대에 오랜 시간이 필요했고,  
나중에 보면 결국 리팩토링할 것들이 많이 보이고, 어떤 건 새로 짜는게 더 깔끔할 것 같다는  
생각까지 들곤 했었다.  
기억하고 싶은 내용을 합치면 결국 같은 맥락인 걸 알 수 있었다.  
</br>
> 나중은 결코 오지 않기에 현재 좋은 코드를 짜야 한다.  
나쁜 코드의 위험을 이해하지 못하는 관리자의 말을 그대로 따르면서 나쁜 코드를 양산하면  
결국 회사에 나쁜 결과를 초례한다.  
</br>

---
### 👀 소감 3줄 요약
- 나중은 결코 오지 않는다.
- '나쁜 코드'를 구분할 줄 안다고 깨끗한 코드를 작성할 줄 아는 건 아니다.
- '코드 감각'을 키워 '깨끗한 코드'로 개선할 최고의 방안을 생각할 수 있는 능력을 키우자.

</br>
</br>

## **_Day 03_**
## TIL(2022.01.23) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 나쁜 코드는 나쁜 코드를 '유혹'한다!  
흔히 나쁜 코드를 고치면서 오히려 더 나쁜 코드를 만든다는 뜻이다.  
  
> 아무리 코드가 우아해도, 아무리 가독성이 높아도,  
테스트 케이스가 없으면 깨끗하지 않다.
  
> 누군가 남겨준 코드, 누군가 주의 깊게 짜놓은 작품에 감사를 느낀다.
  
> 코드를 읽는 시간 대 코드를 짜는 시간 비율이 10 대 1을 훌쩍 넘는다. 새 코드를 짜면서 우리는 끊임 없이 기존 코드를 읽는다.
</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
회사를 다니게 되면 내가 그 회사를 평생 다니는 게 아니다.  
그렇지 않더라도 내가 휴가를 가 있거나, 혹은 무슨 일이 있어서 회사에 없는 경우  
결국 내가 짜놓은 코드를 다른 사람이 참고를 하거나 수정을 할 일이 생긴다.  
  
그럴 때 누군가 내 코드를 클래스 명, 메소드 명, 변수 명만으로 어떤 일을 하는 코드인지  
판단하고 이해할 수 있다면 이건 깨끗한 코드이지 않을까 생각이 든다.  
  
이미 10년도 더 된 이 책에서 테스트 케이스를 벌써부터 강조를 하고 있다.  
테스트 케이스를 배우기 위해 NextStep에 수업도 듣고 큰 감명을 받긴 했지만,  
아직 현장에 적용하는 건 많은 어려움을 느낀다.  
  
좀 더 깨끗한 코드를 위해 테스트케이스 작성이란 작은 한 걸음을 실천해 보도록 노력해야겠다.

</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- 아직 추상화를 크게 이해하지 못했나보다.  
여기서 예로 '집함에서 항목 찾기'를 위해 추상 클래스나 추상 메소드로  
여러 집합을 추상화를 통해 실제 구현을 감싸서 사용한다는 예를 들어주었다.  
아직 코드가 바로 떠오르지가 않아서 아쉬움이 있다.

</br>

---
### 👀 소감 3줄 요약
- 나쁜 코드는 나쁜 코드를 초례한다.
- 아무리 코드가 우아해도, 가독성이 높아도, 테스트 케이스가 없다면 깨끗하지 않다.
- 우리는 기존 코드를 읽는 시간이 새로운 코드를 짜는 시간보다 10 대 1 비율을 넘긴다.

</br>
</br>

# 📘 2장 의미 있는 이름

## **_Day 04_**
## TIL(2022.01.24) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 이름 d는 아무 의미도 드러나지 않는다.  

> isFlagged 좀 더 명시적인 함수를 사용해 'FLAGGED'라는 상수를 감춰도 좋겠다.  

> 새로운 개발자가 들어오면 변수를 설명해 준 다음(올바른 영어 단어가 아니라)  
우리가 만들어낸 발음을 알려줬다.

> 검색하기 쉬운 이름을 사용하라.  
MAX_CLASSES_PER_STUDENT는 찾기 쉽지만, 숫자 7은 은근 까다롭다.

> 헝가리식 표기법이나 기타 인코딩 방식은  
변수, 함수, 클래스 이름이나 타입을 바꾸기가 어려워지며, 읽기도 어렵다.  

> 인터페이스에 접두사를 붙이지 말고, 구현 클래스와 비교를 하기 위해 붙여야 한다면,  
구현 클래스를 택해라.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
> 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다.  

나는 이 말의 의미는 맨 앞 단어라고 생각한다. **_'따로'_**  
이 말은 클래스명, 메소드명, 변수명을 대충 짓고 주석을 통한  
의미전달을 하지 말라는 것으로 생각한다.  

주석을 사용했을 때도 분명 장점이 있다.  
메소드에 주석을 붙이고, API 문서화를 위한 주석을 붙이고,  이러한 이유는 분명 있다.  
클래스 내부에 들어가 메소드를 하나하나 읽으면서 변수명을 읽으면서,  
분석하는 것보다 주석 한두 줄로 해당 메소드의 기능을 파악하기 쉬울 때도 분명 있다는 것이다.  

더군다나 여기는 한국이다. 당연히 영어보다 한글이 더 잘 읽힌다.  
회사는 팀으로 움직이기 때문에 주석을 아예 배제하는 방향이 아닌 적절한 주석은 좋다고 생각한다.  
  
다만 여기서 말하는 클래스명, 메소드명, 변수명 대신 주석을 다는 행위는...🤮🤮
  
거의 21년 여름까지는 변수 명을 'itemList' 이런 식으로 많이 지었다.  
하지만, 책에서 말했듯 저러한 방식은 타입을 변경하기 어렵다는 걸 깨달았다.  
이름 때문에 리팩토링이 어려운 상황은 발생하면 안 된다.

</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- 불용어 : 분석에 큰 의미가 없는 단어  
ex) the, a, an, is, I, my, Info, Data ...
- 

</br>

---
### 👀 소감 3줄 요약
- 이름 대신 다는 주석은 Never!
- 검색하기 쉬운 이름도 검토해 보자.
- 우리가 만들어낸 단어를 지양하고, 쉬운 단어를 지향하자.

</br>
</br>

## **_Day 05_**
## TIL(2022.01.25) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 전문가 프로그래머는 명료함이 **_최고_** 라는 사실을 이해한다.  

> 클래스명과 객체명은 명사나 명사구가 적합하다.  

> 메서드명은 동사나 동사구가 적합하다.  

> 특정 문화에서만 사용하는 농담은 피하는 편이 좋다.  
의도를 분명하고 솔직하게 표현하라.  

> 좋은 이름을 선택하려면 설명 능력이 뛰어나야 하고 문화적인 배경이 같아야 한다.  
이것이 제일 어렵다.  
좋은 이름을 선택하는 능력은 기술, 비지니스, 관리 문제가 아니라 교육 문제다.  
우리 분야 사람들이 이름 짓는 방법을 제대로 익히지 못하는 이유가 바로 여기에 있다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.

여러 사람들과 팀을 이루어서 프로젝트를 진행하다 보면,  
그게 아니더라도 프로젝트가 오래 진행되다 보면,  
당연하게도 프로젝트 크기는 커질 수 밖에 없다.  

이럴 때 프로젝트 내의 명명규칙을 제대로 정하지 않는다면,  
책에 나온 예처럼 어디서는 fetch, retrieve를 쓰고, 어디서는 get을 사용할 것이다.  

이는 프로젝트 전체로 봤을 때 깨끗한 코드와 맞지 않다 생각 되며,  
나중에 봤을 때 혹은 새 팀원이 들어왔을 때 fetch와 get의 차이점을 분석하고 있을 것이다.  
이는 시간 낭비라 생각되며, 시간 낭비는 결국 돈 낭비다.

</br>

어찌 보면 작명소 아저씨보다 우리 프로그래머들이 이름을 더 많이 지을 거다.  
우리가 지은 이름이 오래오래 이름이 이쁘단 소리를 들을 수 있도록,  
하나하나 정성껏 이름을 지어보자.  
나중에 사람들이 이름이 못생겼다고 놀려서 상처받고 개명하면 슬프지 않을까..?

---
### 👀 소감 3줄 요약
- 간단 명료한 단어. 모두가 이해할 수 있는 단어로
- 클래스명은 명사, 메소드명은 동사
- 좋은 이름을 짓기 위해 프로그래밍 영어 단어 공부!

</br>
</br>

# 📘 3장 함수

## **_Day 06_**
## TIL(2022.01.26) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> Sparkle은 모든 함수가 2줄, 3줄, 4줄 정도였다.  

> 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다.  

> 함수는 한 가지를 해야 한다.  
그 한 가지를 잘 해야 한다.  
그 한 가지만을 해야 한다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
Switch 문을 볼 때마다 이건 한 가지 일을 하는 게 아닌데,  
어떻게 줄이지? 안 쓰는게 답인건가?? 그럼 왜 만들었지?? 사용 용도가 있지 않을까??  
라는 의문을 생각하곤 했었다.  
이번 파트를 읽으면서 자바의 다형성을 Switch문과 같이 사용하면,  
저렇게 깔끔한 코드가 나온다는 걸 배울 수 있어서 좋았다.  

인수(파라미터)는 적은 게 제일 좋다고 한다.  
하지만, 프로그래밍은 마음처럼 되지 않는다.  
내가 0개를 쓰고 싶어도 어쩔 수 없는 상황은 발생할 수 밖에 없다.  
그러니 이번 파트에서 꼭 알고 가야 하는 건,  

파라미터가 무조건 0개가 아니라 함수를 만들 때  
더 적은 파라미터를 사용하는 방법이 있을까에 대해서  
충분히 고민을 하고, 고민을 해서 줄이는 방향을 생각하는 습관을 길러야 된다.
</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- 포트란
- PL/1

</br>

---
### 👀 소감 3줄 요약
- 자바 다형성의 강력함
- 플래그 인수는 추하다. 최대한 사용하지 말자.
- 함수를 글처럼 내려가면서 읽을 수 있도록 만들자.

</br>
</br>

## **_Day 07_**
## TIL(2022.01.27) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 오류 처리도 한 가지 작업이다.  

> 반복하지 마라 DRY(Don't Repeat Yourself)

> ~~ 이 와중에도 코드는 항상 단위 테스트를 통과한다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.

### **_(잡담)_**  
지금 이 책을 읽기 불과 3~4시간 전 내가 짠 코드를 리팩토링 하라고 얘기한다.   
try-catch 문 다음에 다른 작업을 진행했었는데,  
Try/Catch 뽑아내기 / 오류 처리도 한 가지 작업이다.(p58-59)
부분을 읽은 후 리팩토링할 아이디어가 떠오른다.    

빨리 내일 출근해서 try-catch 부분을 리팩토링 하고 싶다는 생각이 든다.  

</br>

### **_(3장 함수 내용)_**  
이번 파트에서의 핵심은 '한 가지 작업하는 함수' 라고 생각한다.  
결국 그 한 가지 작업을 표현할 수 있는 함수 명을 지어야 하며,  
큰 함수를 각각의 기능 별로 함수로 분리해서 위에서 부터 읽어내려 가도록  
이야기를 풀어나가는 연습이 필요하다.  

</br>

### **_(결국 우리가 해야하는 것)_**  
단위 테스트의 중요성이 61p 맨 마지막 문구와 62p 맨 첫 문구에서 나왔다.  
처음부터, 완벽하게, 한 번에 멋진 코드를 짜는 사람은 없다.  
만든 코드를 계속해서 리팩토링 하면서 깔끔한 코드로 발전해 나아가야 하는데,  
테스트케이스가 없이 리팩토링을 진행하다 보면 분명 실수가 나오고, 예상치 못한 곳에서  
버그가 발생할 가능성이 항상 존재한다.  
그렇기에 안전하게, 과감하게 리팩토링을 진행하기 위해서는  
무조건 테스트케이스를 먼저 작성을 해두어야 한다.  
그래야만 걱정하지 않고 함수를 수정하고, 분리할 수 있을 것이다.  

나부터 실천하자..!

</br>

---
### 👀 소감 3줄 요약
- try-catch 오류 처리도 한 가지 작업이다.
- 꼭! 한 가지 일만 해라.
- 테스트케이스를 작성해두고, 리팩토링을 진행하자.

</br>
</br>

# 📘 4장 주석

## **_Day 08_**
## TIL(2022.01.28) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.  
> 나쁜 코드에 주석을 달지 마라. 새로 짜라.  

> 몇 초만 더 생각하면 코드로 대다수 의도를 표현할 수 있다.  
많은 경우 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.

나는 주석을 거의 사용하지 않는다.  
가끔 사용하는 주석은 TODO 용도로 내가 어제 하다가 멈춘 부분에 달아 놓고  
다음 날 확인하는 용도나 내가 만들지 않은 코드를 다른 사람에게 알릴 때  
혹은 요구사항이 확정되지 않아서 나중에 검토가 필요한 경우에 달곤 했다.  
  
2장 의미 있는 이름(22p)에서 주석은 나쁜 거라고 얘기했을 때  
그래도 필요한 순간에 적으면 좋은 사용을 할 수 있을 거라 생각은 했지만,  
어느 순간이 좋은 순간인지는 정확히 알지 못했었고,  
이번 파트를 읽으면서 어느 정도 '아 저 때는 고려를 해봐도 좋겠구나!'  
라는 생각이 들 수 있어서 좋았다.  

- 법적인 주석
- 정보를 제공하는 주석
- 의도를 설명하는 주석
- 의미를 명료하게 밝히는 주석
- 결과를 경고하는 주석
- TODO 주석
- 중요성을 강조하는 주석
- 공개 API에서 Javadocs  

이 중에서 **_'의도를 설명하는 주석'_** 은 정말 좋은 주석이라 생각된다.  
팀을 이루어서 개발을 진행할 때 내가 만든 메소드의 의도, 시나리오, 요구사항에 대해  
주석을 사용하여 나중에 내가 보아도 바로 의도를 파악할 수 있고, 다른 팀원이 보아도  
바로 파악할 수 있어서 좋은 주석이라고 생각한다.  
같이 회의했어도 내가 만든 메소드를 모두 다 기억하고 있을 순 없을 테니까.

</br>

---
### 👀 소감 3줄 요약
- 주석은 안 다는 게 가장 좋다.
- 주석을 달겠다고 생각했을 땐 코드로 표현할 수 있을지 고민해본 후 결정하자.
- TODO 주석은 주기적으로 관리해주자.

</br>
</br>

## **_Day 09_**
## TIL(2022.01.29) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 대다수 주석이 이 범주에 속한다.  
일반적으로 대다수 주석은 허술한 코드를 지탱하거나,  
엉성한 코드를 변명하거나, 미숙한 결정을 합리화 하는 등 프로그래머가  
주절거리는 독백에서 크게 벗어나지 못한다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
이번 파트에서는 대부분의 주석이 나쁜 주석으로 설명을 하고, 예를 들어준다.  
예시를 보면서 해당 주석들이 왜 나쁜지, 이런 방식이 잘못된 거라는 걸 알려주어 좋았다.  

사실 어제 **좋은 주석**  부분에서도 주석을 지우고  
다른 방식으로도 표현을 할 수 있을거라 생각을 했었는데,  
이번 p92 목록 4-8 코드에서 리팩터링을 통해 필요없는 주석들을 지우고,    
메소드를 분리하는 방식을 통해 이렇게 진행하면 된다! 라는 걸 보여주는 것 같아서  
앞으로 어떤 방식으로 진행해야 할지 감이 잡히게 되는 좋은 코드였다고 생각한다.  

무서운 잡음 주석은 현재 회사에서 entity에서 진행하고 있는 주석을 보여주었다.  
대부분의 주석들이 필요없는 경우들이지만,  
가끔 비슷한 개념의 단어들을 사용한 컬럼들이 있기에  
한글 주석이 필요하다고 생각하면서 읽어 내려 갔지만,  
결국 생각해보면 2장 의미 있는 이름 을 반영해야 하는 부분이 아닌가란 생각이 든다.

</br>

---
### 👀 소감 3줄 요약
- 소스코드 관리 시스템(git, svn)에 다시 한 번 감사하는 순간
- 주석 처리 코드는 지우고, scm 히스토리를 활용하자.
- 결국 리팩토링을 깔끔하게 하면 거의 웬만한 주석은 필요 없다.

</br>
</br>

# 📘 5장 형식 맞추기

## **_Day 10_**
## TIL(2022.01.30) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 오늘 구현한 기능이 다음 버전에서 바뀔 확률은 아주 높다.  
그런데 오늘 구현한 코드의 가독성은 앞으로 바뀔 코드의 품질에 지대한 영향을 미친다.  

> 500줄이 넘지 않고 대부분 200줄 정도인 파일로도  
커다란 시스템을 구축할 수 있다는 사실이다. (FitNesse는 50,000줄에 육박하는 시스템이다.)  

> 생각 사이는 빈 행을 넣어 분리해야 마땅하다.  

> 서로 밀접한 코드 행은 세로로 가까이 놓여야 한다는 뜻이다.  

> 잘 알려진 위치에 인스턴스 변수를 모은다는 사실이 중요하다.  
변수 선언을 어디서 찾을지 모두가 알고 있어야 한다.  

> 상수를 알아야 마땅한 함수에서 실제로 사용하는 함수로  
상수를 넘겨주는 방법이 더 좋다.  

> 개인적으로는 120자 정도로 행 길이를 제한한다.  

> 프로그래머라면 각자 선호하는 규칙이 있다.  
하지만 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.  
팀은 한 가지 규칙에 합의해야 한다.  
그리고 모든 팀원은 그 규칙을 따라야 한다.  
그래야 소프트웨어가 일관적인 스타일을 보인다.  
개개인이 따로국밥처럼 맘대로 짜대는 코드는 피해야 한다.  

> 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다는 사실을 기억하기 바란다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
코드는 글처럼 술술 읽혀야 한다.  
글을 읽는 데에도 규칙은 있다.  
예를 들어 우리나라는 왼쪽부터 오른쪽으로 읽지만 일본은 오른쪽부터 읽는다.  
이처럼 글 또한 읽는 규칙이 존재한다.  

하나의 소프트웨어에는 규칙이 존재해야 한다.  
이 규칙은 팀 단위일 수 있고, 개인일 수도 있다.  
결국 하나의 규칙을 정해서 그 규칙을 따라 가면서 프로그래밍해야 한다는 게 중요하다.  
그래야만 어느 클래스 파일을 열어 보아도 같은 맥락으로 읽을 수 있을 것이다.

여기서 기억하고 싶은 내용 중 가장 1순위였던 내용은,  
```
프로그래머라면 각자 선호하는 규칙이 있다.  
하지만 팀에 속한다면 자신이 선호해야 할 규칙은 바로 팀 규칙이다.
```
이 내용이었다.  
자신의 코드 스타일과 일치하지 않는 규칙이더라도 하나의 소프트웨어를 만듦에 있어서  
정한 규칙은 필수로 따라서 만드는 습관을 들이면 좋겠다.  
</br>

---
### 👀 소감 3줄 요약
- 하나의 소프트웨어를 만들 땐 규칙을 정하자.
- 특별한 팀 or 개인 규칙이 없다면 유명한 '코드 컨벤션'을 활용하자. (ex - 구글, 네이버)
- 자신의 스타일과 일치하지 않더라도 팀에서 정한 규칙을 따르자.

</br>
</br>

# 📘 번외 - 더러운 코드를 고치자

## **_Day 11_**
## TIL(2022.01.31) 
</br>

### 💩 기존 코드
```
const merry = document.querySelector(".js-clock");

function getClock() {
const christmas = new Date("2021, 12, 25");
const date = new Date();
const timeGap = christmas - date;

const xDay = Math.floor(timeGap / (1000 * 60 * 60 * 24));
const xHours = Math.floor(
(timeGap - xDay * 1000 * 60 * 60 * 24) / (1000 * 60 * 60)
);
const xMinutes = Math.floor((timeGap % (60 * 60 * 1000)) / (60 * 1000));
const xSeconds = Math.floor((timeGap % (60 * 1000)) / 1000);

const day = String(xDay).padStart(2, "0");
const hours = String(xHours).padStart(2, "0");
const minutes = String(xMinutes).padStart(2, "0");
const seconds = String(xSeconds).padStart(2, "0");

merry.innerText = `${day}d ${hours}h ${minutes}m ${seconds}s`;
}

getClock();
setInterval(getClock, 1000);
```


</br>

---
### 😀 수정한 코드
```
const dDay = document.querySelector(".dDay");

function init() {
    setInterval(() => innerTextDDay(new Date()), 1000);
}

function innerTextDDay(date) {
    const { day, hours, minutes, seconds } = getChristmas(date);
    dDay.innerText = `${day}d ${hours}h ${minutes}m ${seconds}s`;
}

function getChristmas(date) {
    const christmas = new Date(`${date.getFullYear()}, 12, 25`);

    const dateGap = christmas.getTime() - date.getTime();
    const timeGap = new Date(0, 0, 0, 0, 0, 0, christmas - date);

    return {
        day: numberToPadStart(getDay(dateGap)),
        hours: numberToPadStart(timeGap.getHours()),
        minutes: numberToPadStart(timeGap.getMinutes()),
        seconds: numberToPadStart(timeGap.getSeconds()),
    };
}

function getDay(time) {
    return Math.floor(time / (1000 * 60 * 60 * 24));
}

function numberToPadStart(number) {
    return String(number).padStart(2, "0");
}

init();
```
</br>

---
### 👀 소감 3줄 요약
- dDay 변수를 저 위치에 두는 게 맞을까?
- padStart 함수를 한 후에 retusn하는 게 맞을까..? 더 쪼갤 수 있을까?
- 오버로딩이 없는 게 매우 아쉽다..

</br>
</br>

# 📘 6장 객체와 자료구조

## **_Day 12_**
## TIL(2022.02.01) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 아무 생각 없이 getter/setter 함수를 추가하는 방법이 가장 나쁘다.  

> 분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다.  
떄로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.  

> 126p  
ctxt는 내부 구조를 드러내지 않으며,  
모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.

java를 주 언어로 사용하는 개발자로서 **_객체지향설계_** 를 중점으로 배우고, 사용하였다.  
그래서 막연히 객체지향이 절차지향보다 당연히 좋다는 편견을 가지고 있었다.  
하지만, 이번 파트를 읽으면서 프로그래머로서 두 설계의 차이점을 명확히 알고  
상황에 맞게 좋은 설계를 하는 것이 올바른 프로그래머란 걸 깨닫게 되었다.  

두 설계의 차이점을 명확히 알고 사용하도록 하자!  

새로운 메소드 추가 시
- 절차지향 : 기존 자료 구조를 변경하지 않고, 쉽게 추가할 수 있다.
- 객체지향 : 사용 되는 모든 클래스를 수정해야 한다.
  
새로운 자료구조 추가 시
- 절차지향 : 모든 메소드를 수정해야 한다.
- 객체지향 : 쉽게 새로운 클래스를 추가할 수 있다.

</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- 활성 레코드
    - 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 객체 (ex - DTO)
    - getter / setter 메소드와 save 혹은 find와 같은 탐색 메소드도 있는 자료구조 형 객체
    - 활성 레코드는 자료구조로 취급한다.
    - 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.

</br>

---
### 👀 소감 3줄 요약
- 객체지향 / 절차지향 차이점을 알고 사용하자.
- 무조건 객체지향이 옳은 설계는 아니다.
- DTO 객체에 비즈니스 메소드를 사용하지 말자.

</br>
</br>

# 📘 7장 오류처리

## **_Day 13_**
## TIL(2022.02.02) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 먼저 강제로 예외를 일으키는 테스트 케이스를 작성한 후  
테스트를 통과하게 코드를 작성하는 방법을 권장한다.  
그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로  
범위 내에서 트랜잭션 본질을 유지하기 쉬워진다.  

> 확인된 예외는 OCP (Open Closed Principle)를 위반한다.  

> 최하위 단계에서 최상위 단계까지 연쇄적인 수정이 일어난다.  
throws 경로에 위치하는 모든 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
이번 챕터를 통해서 unChecked 예외가 Checked 예외보다 왜 좋은지를 알 수 있어서 좋았다.  
Checked 예외가 OCP를 위반하고, 캡슐화를 깨며, 의존성이란 비용이 든다는 사실은  
이야기를 듣기 전까지는 생각하지 못했던 내용이었기에 나에겐 신선한 충격이었다.  
지금까지 마구잡이로 두 예외를 사용했지만,  
이번을 계기로 unChecked 예외를 왜 사용해야 하는지를 알고 사용할 수 있게 되어 기쁘다.  

물론, Checked 예외가 필요한 경우도 있을 것이기 때문에 항상 생각하면서 작성하자!

</br>

---
### 👀 소감 3줄 요약
- 예외를 일으키는 메소드를 작성할 땐 예외를 발생시키는 테스트 케이스를 작성하자.
- Checked 예외보단 unChecked 예외의 장점이 더욱 크다.
- Checked 예외는 OCP를 위반하고, 캡슐화를 깨고, 의존성 비용이 든다.

</br>
</br>


## **_Day 14_**
## TIL(2022.02.03) 
</br>

## 😎 Chapter 4 & 5 & 6 Quiz  

### 1. Is better to write code that does not need comments.
- <span style="color:red">**True**</span>
- ~~False~~

### 2. We write comments when we fail to communicate using only our code.
- <span style="color:red">**True**</span>
- ~~False~~

### 3. We should try to minimize comments as much as possible by writing better code.
- <span style="color:red">**True**</span>
- ~~False~~

### 4. The best place to find information about the code is should be the code itself rather than comments.
- <span style="color:red">**True**</span>
- ~~False~~

### 5. Where should we declare our variables in a function?
- <span style="color:red">**At the top of the function.**</span>
- ~~Only just before we use them.~~

### 6. If one function calls another, they should be vertically close.
- <span style="color:red">**True**</span>
- ~~False~~

### 7. A function that is called should be below a function that does the calling.
- <span style="color:red">**True**</span>
- ~~False~~

### 8. What does DTO mean?
- <span style="color:red">**Data Transfer Object**</span>
- ~~Date Time Object~~

### 9. When do we use DTOs?
- <span style="color:red">**When working with DBs or parsing WebSocket messages.**</span>
- ~~When publishing and transferring our code.~~

### 10. Objects expose functions to operate in their data.
- <span style="color:red">**True**</span>
- ~~False~~


---

</br>
</br>

# 📘 7장 예외처리

## **_Day 15_**
## TIL(2022.02.04) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 예외가 논리를 따라가기 어렵게 만든다. 특수 상황을 처리할 필요가 없다면 더 좋지 않을까?  
그러면 코드가 훨씬 더 간결해지리라. 다음을 살펴보자.  

Before
```
try {
    MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
    m_total += expenses.getTotal();
} catch (MealExpensesNotFound e) {
    m_total += getMealPerDiem();
}
```
After
```
MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());
m_total += expenses.getTotal();
```

> 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다.  
그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다.  
즉, 인수로 null이 넘어오면 코드에 문제가 있다는 말이다.  
이런 정책을 따르면 그만큼 부주의한 실수를 저지를 확률도 작아진다.
</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
모든 상황들을 예외로 던지는 행위는 불필요한 예외처리들을 많이 양산하는 결과를 초례할 수 있다.  
그보다는 객체 내에서 메소드를 통해 처음부터 정상적인 값을 보낼 수 있도록 하는 것이  
어쩌면 더 깔끔한 방법을 만들 수 있다는 걸 알았다.  

null은 항상 불편한 존재이다.  
null 포인터라는 개념을 만든 '토니 호어' 프로그래머는 강연에서 이런 말을 했다.  
**_null pointer는 내 10억 달러짜리 실수였다.  
이 결정은 셀 수도 없는 오류와 보안 버그, 시스템 다운을 낳았다.  
지난 40년 동안 이러한 문제들 때문에 입은 고통과 손해는 10억 달러는 될 것이다._**  
이만큼 null이 만들어낼 실수와 오류, 버그들은 무궁무진하다.  
그렇기 때문에 null은 절대로, 절대로 우리가 만드는 일은 없어야 한다.  

null 대신 객체를 초기화하는 습관을 기르자.  
(예시)
```
// No
Car morning = null;
// Good
Car morning = new Car();
```

</br>

---
### 👀 소감 3줄 요약
- 예외반환 대신, 정상흐름을 검토해보자.
- null은 절대 반환하지 마라.
- null은 절대 전달하지 마라.

</br>
</br>

## **_Day 16_**
## TIL(2022.02.05) 
</br>

### 😀 내가 뽑은 BEST 3 TIL  

@Jason Park 님의 [Day 11 TIL](https://github.com/jpark-dev/TIL/blob/main/books/clean%20code/Day11.md)  
> **더러운 코드를 고쳐봅시다! 미션** 에서 리팩토링한 코드 중 내 생각에는  
가장 메소드를 역할에 맞게 잘 나누었다고 느꼈다.    
innerText를 어디에 두는 게 맞을까란 고민을 하면서 진행했었는데,  
리팩토링해주신 코드를 보고 '아 이런 방법이 있구나'를 느껴서 좋았다.

@Roxy 님의 [TIL](https://jiyoungyim100.notion.site/Today-I-Read-Roxy-2e64de4a43464c31aa51634e68894bd6)  
> **책에서 기억하고 싶은 내용을 써보세요.** 를 책 내용의 핵심들을 가장 깔끔하게 정리하셨다고 느꼈다.      
본인이 중요하다고 생각하시는 부분에 색상으로 구분해주셔서 보기가 더 좋았다.  
책 내용을 나중에 한 번 더 훑어보고 싶을 때 정리해주신 내용만 봐도  
어느정도 충분할 것 같다는 느낌까지 받았다.  

@붕빵 님의 [Day 10 TIL](https://hurricane-rudbeckia-0cc.notion.site/TIL-2022-01-30-b808d4ebb89f4c53a4149b4a0ecf069f)  
> 맹목적으로 책에 내용을 따르는 것이 아닌 본인의 주관을 적어주셔서 인상적이었다.  
책을 읽는 것에서 그치지 않고, 다른 코드 컨벤션을 찾아보면서 공부하려고 하시는 모습이  
나도 더 열심히 해야겠다는 느낌을 주셔서 좋았다.


</br>

---

# 📘 8장 경계

</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 외부 코드를 익히기는 어렵다.  
외부 코드를 통합하기도 어렵다.  
두 가지 동시에 하기는 두 배나 어렵다.  
다르게 접근하면 어떨까?  
곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신  
먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까?  
짐 뉴커크는 이를 **학습 테스트** 라 부른다.  

> 학습 테스트는 공짜 이상이다.  
투자하는 노력보다 얻는 성과가 더 크다.  
패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.  

> 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자.  

> 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는  
인터페이스를 패키지가 제공하는 인터페이스로 변환하자.  
어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며,  
외부 패키지가 변했을 때 변경할 코드도 줄어든다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
개발을 할 때 외부 라이브러리, 심지어 우리가 만들 프로젝트의 기반이 되는 프레임워크 등  
우리는 수많은 우리가 만들 외의 코드들을 많이 사용한다.  
지금까지 이 외부 코드들을 사용하면서 의심을 해본 적이 거의 없다.  
 
하지만, 이번 챕터를 읽으면서 외부 라이브러리들도 우리가 사용하는 부분들은  
'학습 테스트'라는 용어를 가진 테스트코드를 작성해 두면,  
나중에 버전이 바뀌어도 쉽게 테스트를 진행한 후 안심해서 사용할 수 있다는 걸  
깨닫게 되었다.

</br>

---
### 👀 소감 3줄 요약
- 다른 사람들 TIL도 이번 기회에 많이 읽어봐서 좋은 시간이었다.
- 외부 코드들도 '학습 테스트'를 작성해두면 좋다.
- 아직 만들어지지 않은 코드들은 어댑터 패턴을 활용해보자.

</br>
</br>

# 📘 9장 단위 테스트

## **_Day 17_**
## TIL(2022.02.06) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> TDD 법칙 세 가지  
- 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.  
- 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.  
- 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.  

> 테스트 코드는 실제 코드 못지 않게 중요하다.  

> 테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다.  
단순하고, 간결하고, 표현력이 풍부해야 하지만,  
실제 코드만큼 효율적일 필요는 없다.  

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
항상 중요하게 생각하는 테스트 코드. 그 중에서도 TDD 방법론을 설명하는 챕터였다.  
하지만, 중요하다는 걸 알고 실천하는 건 다른문제다.  
나는 항상 테스트 코드가 중요하다는 걸 알지만, TDD를 따라하기엔 벅찼다.  
실패하는 코드부터, 성공하는 코드까지.. 내가 무얼 어디까지 작성해야 하는지 항상 막막했다.  
이번 기회에 다시 TDD를 머리에 세기고 한 번 열심히 해봐야겠다.  

이번 챕터에서 인상적이었던 부분은 **'그릇된 정보를 피하라'** 라는 규칙을 어겼다는 것이다.  
처음보는 사람은 알기 어려운 문자 조합을 통해 테스트 케이스를 작성했다.  
뜻을 알고 본다면 눈에 익은 후부터는 잘 보이겠지만.. 맞다고는 생각하기 어렵다.  
만약 장비가 추가된다면 저걸 다시 모든 테스트케이스를 포함해서 저 단어까지 변경해야 한다.  
만얀, 단어를 변경 안하고, 케이스만 변경을 진행하게 되면 결국 모르는 뜻을 가지고 전해질 것이다.  
그렇다고 주석을 달자면.. 주석도 변경되지 않을 가능성이 있다.  
이해하기 쉽다고 설명으로 적었지만.. 글쎄.. 확장성은 고려하지 못한 코드라 생각된다.

</br>

---
### 👀 소감 3줄 요약
- TDD 공부를 다시 시작하자.
- 테스트 코드는 실제 코드 못지 않게 중요하다.
- 테스트 코드는 실제 코드만큼 효율적일 필요는 없다.

</br>
</br>

## **_Day 18_**
## TIL(2022.02.07) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
```
가장 좋은 규칙은
- "개념 당 assert 문 수를 최소로 줄여라"  
- "테스트 함수 하나는 개념 하나만 테스트하라"
```

```
F.I.R.S.T.

Fast(빠르게)
- 테스트는 빨라야 한다.  
느리면 자주 돌릴 엄두를 못 낸다.  
자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다.  
코드를 마음껏 정리하지도 못한다.  
결국 코드 품질이 망가지기 시작한다.  

Independent(독립적인)
- 각 테스트는 서로 의존하면 안 된다.  
어떤 순서로 실행해도 괜찮아야 한다.  
테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로  
원인을 진단하기 어려워 지며 후반 테스트가 찾아내야 할 결험이 숨겨진다.  

Repeatable(반복성)
- 어떤 환경에서도 실행되어야 한다.  
실제환경, 테스트환경, 네트워크가 연결되지 않은 환경에서도 실행할 수 있어야 한다.  
환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면해서는 안된다.  

Salf-Validating(자가검증)
- 결과는 Boolean 값으로 나와야 한다. 성공 or 실패로.  
통과 여부를 알려고 로그를 찍어서는 안 된다.  
테스트가 스스로 성공과 실패를 가늠하지 않는다면  
판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.

Timely(적시에)
- 단위 테스트는 테스트 하려는 실제 코드를 구현하기 직전에 구현해야 한다.  
실제 코드를 구현한 다음에 테스트 코드를 만들면  
실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.  
어떤 실제 코드는 테스트하기 너무 어렵다고 판명날지 모른다.  
테스트가 불가능하도록 실제 코드를 설계할지도 모른다.
```

> 테스트 코드가 방치되어 망가지면 실제 코드도 망가진다. 테스트 코드를 깨끗하게 유지하자.
</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
나는 지금까지 테스트 메소드 하나에는 무조건 assert가 하나가 있어야 된다고 생각했다.  
"테스트당 assert 하나" 파트에서 훌륭하지만 여러 개를 사용하는 게  
더 좋은 상황이 있다고 설명을 하는 부분에서도  
"잘만 쪼개면 하나를 만들 수 있지 않을까?" 라는 생각을 가지고 읽었다.    

그렇지만, 다음 파트인 "테스트 당 개념 하나"를 읽고 설득 당해버렸다.  
한 개념에 여러 상황이 있고, 그 상황들을 테스트를 해야 하는데 그 모든 상황들을  
하나하나 메소드를 분리하는 게 가독성이 더 안좋고, 관리하기가 어렵겠다는 생각이 들게 되었다.  

예시를 들어준 저러한 상황을 보니, 마지막에 말한 규칙 두 가지가 공감이 되고,  
역시 선배 개발자가 하는 말은 이유가 있다는 생각을 갖게 되었다.  

이번 파트로 나의 생각을 전환할 수 있는 계기가 되어서 매우 만족했다.

</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- 도메인 특화 언어(DSL : Domain Specific Language)
```
- 해당 언어(도메인)에 특화된 언어(?)
예시 JAVA
- 메서드 체인, 중첩 함수, 람다 함수 시퀀싱, junit 등등..
해당 언어에서 특화된 기술
```
- 

</br>

---
### 👀 소감 3줄 요약
- "개념 당 assert 문 수를 최소로 줄여라"  
- "테스트 함수 하나는 개념 하나만 테스트하라"
- F.I.R.S.T. 를 생각하면서 작성하자.

</br>
</br>


## **_Day 19_**
## TIL(2022.02.08) 
</br>

## 😎 Chapter 7 & 9 Quiz  

### 1. What is better, to throw Exceptions or return error codes?
- ~~Error Codes~~
- <span style="color:red">**Exceptions**</span>

### 2. When should we write try/catch/finally?
- <span style="color:red">**First, before we write any code.**</span>
- ~~At the end, when cleaning the code.~~

### 3. What kind of information should our error messages have?
- ~~The stack trace only.~~
- <span style="color:red">**The operation that failed, type of failure, more information about the error.**</span>

### 4. Why shouldn’t we return ‘null’ from methods/functions?
- <span style="color:red">**We might forget to check for null and can easily have null pointer exceptions.**</span>
- ~~The code does not run.~~

### 5. Is passing ‘null’ as an argument a good practice? 
- ~~Yes~~
- <span style="color:red">**No**</span>

### 6. Having dirty tests can be worse than having no tests at all
- <span style="color:red">**True**</span>
- ~~False~~

### 7. Test code is as important as production code.
- <span style="color:red">**True**</span>
- ~~False~~

### 8. How many concepts should a test function test?
- ~~Multiple~~
- <span style="color:red">**One**</span>

### 9. Should tests depend on each other
- ~~Yes~~
- <span style="color:red">**No**</span>

### 10. What output should a test have?
- <span style="color:red">**Boolean**</span>
- ~~None, throw an error.~~

</br>
</br>

# 📘 10장 클래스

## **_Day 20_**
## TIL(2022.02.09) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 테스트 코드가 함수를 호출하거나 변수를 사용해야 한다면  
그 함수나 변수를 protected로 선언하거나 패키지 전체로 공개한다.  
하지만 그 전에 비공개 상태를 유지할 온갖 방법을 강구한다.  
캡슐화를 풀어주는 결정은 언제나 최후의 수단이다.  

> 단일책임원칙(Single Responsibility Principle, SRP)은  
클래스나 모듈을 변경할 이유가 하나, 단 하나뿐이어야 한다는 원칙이다.  

> 강조하는 차원에서 한 번 더 말하겠다.  
큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다.  
작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며,  
다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다.  

> 큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다.  
큰 함수 일부를 작은 함수 하나로 빼내고 싶은데,  
빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다.  
그렇다면 변수 네 개를 새 함수에 인수로 넘겨야 옳을까?  
전혀 아니다! 만약 네 변수를 클래스 인스턴스 변수로 승격한다면  
새 함수는 인수가 필요없다. 그만큼 함수를 쪼개기 쉬워진다.  

> 잠깐만! 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리해도 되지 않는가?  
당연하다. 클래스가 응집력을 잃는다면 쪼개라!  
그래서 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다.  
그러면서 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다.  

> 가장 먼저, 원래 프로그램의 정확한 동작을 검증하는 테스트 슈트를 작성했다.  
그런 다음, 한 번에 하나씩 수 차례에 걸쳐 조금씩 코드를 변경했다.  
코드를 변경할 때마다 테스트를 수행해 원래 프로그램과 동일하게  
동작하는지 확인했다.  
조금씩 원래 프로그램을 정리한 결과 최종 프로그램이 얻어졌다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
이번 파트는 큰 메소드를 리팩토링 하는 방법이 아주 상세히, 자세히, 친절히 설명해주셨다.  
인스턴스 수는 작아야 하며, 함수도 작아야 하고, 클래스도 작아야 한다.  
여기서 중요한 키워드가 **_응집도_** 라고 생각됐다.  
```
큰 함수를 쪼깨져 나온 작은 함수에 사용되는 변수들을 인수로 넘기는 게 아니라,  
새로운 클래스의 인스턴스로 만들어서 하나의 클래스의 응집도를 높인다.  
```
지금까지는 막연히 큰 함수를 private 한 작은 함수들로만 나누는 걸  
리팩토링의 끝이라고 생각하면서 열심히 나누었다.  

하지만, 이번 파트를 읽으면서 해당 클래스의 역할은 하나이며,  
그 역할을 수행하기 위해 여러 클래스들을 만들 수도 있고,  
나눠진 함수들에 사용되는 변수들을 인스턴스로 선언하여 응집도를 높이는 방향으로  
생각을 전환한다면 지금보다 조금 더 명확한 목적을 가지고 리팩토링을 진행할 수 있을 거라 생각됐다.  

이번 파트는 정말 큰 함수, 여러 역할, 책임을 가진 클래스를 쪼개는 방법을  
정말 잘 설명해주었다고 생각된다.  

여기서 리팩토링 할 때 가장 중요한 말도 해주었다.  
기존에 돌아가는 코드가 새로운 버그나, 오류가 발생하는 걸 막기 위해  
기존 코드의 테스트 코드를 작성한 후 하나하나 분리를 하면서  
계속해서 기존 테스트 코드가 동작하는지 확인하면서 리팩토링을 하라고 알려주셨다.  
이러면, 더욱더 안전한 리팩토링을 진행할 수 있다고 생각된다.
</br>

---
### 👀 소감 3줄 요약
- 한 클래스, 하나의 메소드는 하나의 역할만.
- 큰 함수를 분리할 때 분리된 작은 함수들에 사용되는 변수들을 인스턴스로 전환되는지 생각해보자.
- 리팩토링 전에는 테스트 코드를 만들어 두고 시작하는 방식으로 안전하게 진행하자.

</br>
</br>

## **_Day 21_**
## TIL(2022.02.10) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 187~188p 목록 10-10 코드  
우리가 재구성한 Sql 클래스는 파생 클래스를 생성하는 방식으로  
새 기능에 개방적인 동시에 다른 클래스를 닫아놓는 방식으로  
수정에 폐쇄적이다. 그저 UpdateSql 클래스를 제자리에 끼워 넣으면 끝난다.  

> 새 기능을 수정하거나 기존 기능을 변경할 때 건드릴 코드가  
최소인 시스템 구조가 바람직하다.  
이상적인 시스템이라면 새 기능을 추가할 때 시스템을 확장할 뿐 기존 코드를 변경하지 않는다.

> 요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다.  

> 상세한 구현에 의존하는 코드는 테스트가 어렵다.  

> DIP(Dependency Inversion Principle)  
클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
현재 나는 실무에서 쿼리(테이블) 기반으로 코드를 작성한다.  
그래서 sql 클래스를 보았을 때 공감이 많이 갔다.  
왜냐하면 현재 설계하는 방식이 한 테이블의 기능을 한 서비스 클래스에 모두 구현을 하는  
형태로 진행하고 있었고, 그게 관리하기 편하다고 생각했었다.  

하지만, 이번 sql을 분리하는 예제를 보면서 저런 추상화로 분리까지는 없지만,  
굳이 한 클래스 안에 안 넣고 여러 클래스로도 분리가 가능하고, 그래도 관리가 되겠다고 생각됐다.

실무에서는 수시로 바뀌는 요구사항과, db를 가지고 코드를 작성한다.  
그렇기에 구현이 다 되어있는 코드를 테스트하려면 여러 외부 요인들 때문에  
테스트 코드 작성이 아주 어려워지곤 했었다.  
이번 파트에서 보여준, 구현은 숨기고 인터페이스를 노출하는 방법은 아주 유용하고,  
꾸준히 해야 되는 내용이라고 보이지만, 막상 실무에 적용하려고 하면 잘 감이 잡히지 않는다.  
연습.. 또 연습.. 많은 연습이 필요할 것 같다.
</br>

---
### 👀 소감 3줄 요약
- 요구사항은 변하기 마련이다. 따라서 코드도 변하기 마련이다.
- 상세한 구현에 의존하는 코드는 테스트가 어렵다.
- 상세한 구현이 아니라 추상화에 의존해야 한다.

</br>
</br>

# 📘 11장 시스템

## **_Day 22_**
## TIL(2022.02.15) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 체계적이고 탄탄한 시스템을 만들고 싶다면 흔히 쓰는 좀스럽고 손쉬운 기법으로 모듈성을 깨서는 절대로 안 된다.  

> 설정 논리는 일반 실행 논리와 분리해야 모듈성이 높아진다.  
또한 주요 의존성을 해소하기 위한 방식, 즉 전반적이며 일관적인 방식도 필요하다.  

> Main 분리  
시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로,  
생성과 관련한 코드는 모두 main이나 main이 호출하는 모듈로 옮기고,  
나머지 시스템은 모득 객체가 생성되었고, 모든 의존성이 연결되었다고 가정한다.  

> 팩토리 Abstract Factory (추상 팩토리 패턴)  

> 의존성 주입 (Dependency Injection, DI)  
의존성 주입은 제어 역전(iNVERSION OF cONTROL IoC) 기법을 의존성 관리에 적용한 메커니즘이다.  
대다수 DI 컨테이너는 필요할 때까지는 객체를 생성하지 않고,  
대부분은 계산 지연이나 비슷한 최적화에 쓸 수 있도록 팩토리를 호출하거나  
프록시를 생성하는 방법을 제공한다.  
즉, 계산 지연 기법이나 이와 유사한 최적화 기법에서 이런 메커니즘을 사용할 수 있다.  

> 성장할지 모른다는 기대로 자그만 마을에 6차선을 뚫는데 들어가는 비용을 정당화할 수 있을까?  
아니, 어느 조그만 마을이 6차선을 반길까?  

> "처음부터 올바르게" 시스템을 만들 수 있다는 믿음은 미신이다.  
대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다.  
내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.  
이것이 반복적이고 점진적인 애자일 방식의 핵심이다.  
테스트 주도 개발(TDD), 리팩터링, (TDD와 리팩터링으로 얻어지는) 깨끗한 코드는  
코드 수중에서 시스템을 조정하고 확장하기 쉽게 만든다.  

> 소프트웨어 시스템은 물리적인 시스템과 다르다.  
관심사를 적절히 분리해 관리한다면 소프트웨어 아키텍처는 점진적으로 발전할 수 있다.  

> AOP에서 관점(aspect)이라는 모듈 구성 개념은  
"특정 관심사를 지원하려면 시스템에서 특정 지점들이 동작하는 방식을 일관성 있게 바꿔야 한다." 라고 명시한다.  
명시는 간결한 선언이나 프로그래밍 메커니즘으로 수행한다.

</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
이번 파트는 객체지향에 전형적인 내용들이 많이 포함되어 있었다.  
결국 이번 파트에서 이야기하고 싶은 내용은,  
생성부분과 사용하는 서비스 부분을 분리하는 게 중요하다는 말을 하고싶은 것 같다.  

분리할 수 있는 방법은 여러 방법이 있는데,  
유명한 GoF의 디자인 패턴을 슬슬 공부해야 할 것 같다.  

"처음부터 올바르게" 시스템을 만들 수 있다는 믿음은 미신이다.  
라는 말에 매우 공감했다.  
처음부터 완벽하게 설계를 하려고 하면 시간만 많이 잡아먹게 되고,  
어차피 완벽하게 설계하지 못한다. 결국 시간만 버리게 된다.  
이제는 어느정도 설계가 되면 구현하면서 바뀌어가는 스토리에 맞게 구현하는 방식에  
애자일 방식에 익숙해져야 할 때이지만.. 말처럼 쉽게 되진 않는 것 같다.  
노력해야지..
</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- JNDI

</br>

---
### 👀 소감 3줄 요약
- "처음부터 올바르게" 시스템을 만들 수 있다는 믿음은 미신이다.
- 대신에 우리는 오늘 주어진 사용자 스토리에 맞춰 시스템을 구현해야 한다.
- 내일은 새로운 스토리에 맞춰 시스템을 조정하고 확장하면 된다.

</br>
</br>

## **_Day 23_**
## TIL(2022.02.16) 
</br>

### 😀 책에서 기억하고 싶은 내용을 써보세요.
> 흔히 (메서드 가로채기, 프록시를 통한 '감싸기' 등) AOP를 구현하는 기법과 AOP 자체를 혼동한다.  
AOP 시스템의 진정한 가치는 시스템 동작을 간결하고 모듈화된 방식으로 명시하는 능력이다.  

> POJO는 순수하게 도메인에 초점을 맞춘다.  
POJO는 엔터프라이즈 프레임워크에 (그리고 다른 도메인에도) 의존하지 않는다.  
따라서 테스트가 개념적으로 더 슆고 간단하다.  
상대적으로 단순하기 때문에 사용자 스토리를 올바르게 구현하기 쉬우며,  
미래 스토리에 맞춰 코드를 보수하고 개선하기 편하다.  

> 일부 상세한 엔티티 정보는 애너테이션에 포함되어 그대로 남아있지만,  
모든 정보가 애너테이션 속에 있으므로 코드 자체는 깔끔하고 깨끗해졌다. (POJO)  
즉, 그만큼 코드를 테스트하고 개선하고 보수하기가 쉬워졌다.  

> 최선의 시스템 구조는 각기 POJO (또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다.  
이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나  
유사한 도구를 사용해 통합한다.  
이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다.

> 도시든 소프트웨어 프로젝트든, 아주 큰 시스템에서는 한 사람이 모든 결정을 내리기 어렵다.  
가장 적합한 사람에게 책임을 맡기면 가장 좋다.  
우리는 때때로 가능한 마지막 순간까지 결정을 미루는 방법이 최선이라는 사실을 까먹곤 한다.  
게으르거나 무책임해서가 아니다.  
최대한 정보를 모아 최선의 결정을 내리기 위해서다.  
성급한 결정은 불충분한 지식으로 내린 결정이다.  
너무 일찍 결정하면 고객 피드백을 더 모으고, 프로젝트를 더 고민하고,  
구현 방안을 더 탐험할 기회가 사라진다.  

> 모든 추상화 단계에서 의도는 명확히 표현해야 한다.  
그러려면 POJO를 작성하고 관점 혹은 관점과 유사한 메커니즘을 사용해  
각 구현 관심사를 분리해야 한다.  

> 시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을  
사용해야 한다는 사실을 명심하자.
</br>

---
### 🤔 오늘 읽은 소감은? 더오르는 생각을 가볍게 적어보세요.
이번 파트를 읽으면서 크게 느낀 부분이 있다.  
내 윗세대, 윗윗세대.. 다들 많은 시행착오들을 거쳐서 지금 Spring, Spring Boot가 탄생하게 되었고,  
이제 개발을 시작하는 나와 같은 사람들은 저런 복잡한 로직을 모른 채 편리하게, 더 쉽게,  
도메인에 집중해서 개발을 할 수 있게 됐다는 거에 감사함을 느낀다.  

EJB2를 잠깐만 봐도 현대의 표준인 Spring이 얼마나 대단한지 느낄 수 있고,  
알아보기가 어려운 xml 대신 자바 코드로 설정할 수 있는 Spring boot 에 고맙다.  

하지만, 감사함으로 끝내서는 안 된다.  
이번 파트를 통해 어떻게 탄생했는지를 알게 되었으니,  
더 깊게 들어가서 Spring이 어떻게 도메인에 집중할 수 있도록 설계가 되어 있는지를 공부해야 한다.  
다양한 디자인패턴과 Spring의 핵심 요소인 IoC, DI, AOP, PSA.. 깊게 공부해보자!  

한 번에 완벽한 설계와 구현은 할 수 없다.  
하지만, 점차 리팩토링 할 수 있도록 다양한 기법을 익히고 연마해서  
필요한 시점에, 가능한 시간에 적용할 수 있도록 미리미리 연습해두자.
</br>

---
### 🔎 궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.
- 데코레이터 패턴
- BDUF(Big Design Up Front) 구현을 시작하기 전에 앞으로 벌어질 모든 사항을 설계

</br>

---
### 👀 소감 3줄 요약
- 선배 개발자님들의 노력의 산물인 Spring 감사합니다.
- Spring이 어떻게 도메인에 집중할 수 있도록 해주는지 앞으로 공부해 나아가자.
- POJO! 도메인 설계에 집중할 수 있도록, 테스트가 가능하도록, 의존성을 줄이자!

</br>
</br>

#노마드클럽 #북클럽 #노개북