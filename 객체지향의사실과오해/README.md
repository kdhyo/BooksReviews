# 객체지향의 사실과 오해

이야기해볼 거리
1. 자율적인 객체란 상태와 행위를 지닌 객체다. 그러면 우리가 흔히 쓰는 컨트롤러, 서비스, 레파지토리는 객체지향 설계라고 볼 수 있을까?
2. 객체는 행동을 통해 상태를 변경할 수 있어야 자율적이고 유연한 객체라고 설명한다. 그렇다면 불변객체는 객체지향 패러다임과 일치하지 않는 설계인가?
3. 설계를 진행할 때 차이점은 과감하게 무시하고 공통점만을 취해 단순화하는 생각이 필요하다.


## 01. 협력하는 객체들의 공동체

```
시너지를 생각하라. 전체는 부분의 합보다 크다.  
- 스티븐 코비(Stephen R. Covey)
```

> 실세계의 모방이라는 개념은 객체지향의 기반을 이루는 철학적인 개념을 설명하는 데는 적합하지만  
> 유연하고 실용적인 관점에서 객체지향 분석, 설계를 설명하기에는 적합하지 않다.

> 객체지향의 목표는 실세계를 모방하는 것이 아니다.  
> 오히려 새로운 세계를 창조하는 것이다.  
> 소프트웨어 개발자의 역할은 단순히 실세계를 소프트웨어 안으로 옮겨 담는 것이 아니라  
> 고객과 사용자를 만족시킬 수 있는 신세계를 창조하는 것이다.

> 객체를 스스로 생각하고 결정하는 현실 세계의 생명체에 비유하는 것은 상태와 행위를 '캡슐화'하는  
> 소프트웨어 객체의 '자율성'을 설명하는 데 효과적이다.

### 손님 - 캐시어 - 바리스타
> 각자의 역할은 주문할책임, 주문받고 전달하는 책임, 커피를 만드는 책임으로 존재한다.  
> 각자의 역할은 서로 협력을 통해서 최종적으로 커피를 만들고, 전달하는 공통적인 목표가 있다.

### 역할, 책임, 협력

- 여러 객체가 동일한 역할을 수행할 수 있다.
- 역할은 대체 가능성을 의미한다.
- 각 객체의 책임을 수행하는 방법은 자율적으로 선택할 수 있다.
- 하나의 객체가 동시에 여러 역할을 수행할 수 있다.

### 협력 속에 사는 객체

#### 두 가지의 덕목
- 객체는 '협력적'이어야 한다.
- 객체는 '자율적'이어야 한다.

> 객체 공동체에 속한 객체들은 공동의 목표를 달성하기 위해 협력에 참여하지만,  
> 스스로의 결정과 판단에 따라 행동하는 자율적인 존재하다.

#### 상태와 행동을 함께 지닌 자율적인 객체

> 객체를 상태(state)와 행동(behavior)을 함께 지닌 실체라고 정의한다.  
> 커피를 제조하는 바리스타가 제조 방법을 모른다는 것이 말이 되지 않는 것처럼  
> 객체가 어떤 행동을 하기 위해 필요한 상태를 알지 못한다는 것 역시 말이 되지 않는다.

> 객체는 다른 객체가 '무엇(what)'을 수행하는지는 알 수 있지만, '어떻게(how)'수행하는지에 대해서는 알 수 없다.

> 객체지향에서는 데이터와 프로세스를 객체라는 하나의 틀 안에 함께 묶어 놓음으로써 객체의 자율성을 보장한다.  
> 자율적인 객체로 구성된 공동체는 유지보수가 쉽고 재사용이 용이한 시스템을 구축할 수 있는 가능성을 제시한다.

#### 협력과 메시지 / 메서드와 자율성

> 객체지향의 세계에서는 오직 한 가지 의사소통 수단만이 존재한다. 이를 '메시지'라고 한다.  

> A객체에서 B객체에게 요청하는 것을 메시지 전송, 요청을 받는 B객체에서는 메시지를 수신한다고 한다.  

> 메시지를 전송하는 객체를 송신자(sender), 메시지를 수신하는 객체를 수신자(receiver)라고 부른다.

> 메시지 처리 방법을 메서드(method)라고 부른다.  
> 클래스 안에 포함된 함수 또는 프로시저를 통해 구현이 된다.  
> 메서드 호출을 전송이라고 표현하며, 메서드 실행을 수신이라고 표현한다.

> 외부의 요청이 무엇인지를 표현하는 메시지와 요청을 처리하기 위한 구체적인 방법인 메서드를 분리하는 것은 객체의 자율성을 높이는 핵심 메커니즘이다.  
> 이것은 캡슐화라는 개념과도 깊이 관련돼 있다.  
> 메시지를 인터페이스, 메서드를 구현객체라고 생각할 수 있을 것 같다.


### 객체지향의 본질

- 객체지향이란 시스템을 상호작용하는 **자율적인 객체들의 공동체**로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
- 자율적인 객체란 **상태**와 **행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 **협력**한다. 각 객체는 협력 내에서 정해진 **역할**을 수행하며 역할은 관련된 **책임**의 집합이다.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, **메시지**를 수신한 객체는 메시지를 처리하는 데 적합한 **메서드**를 자율적으로 선택한다.

#### 객체를 지향하라

> 지나치게 클래스를 강조하는 프로그래밍 언어적인 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합시킨다.  
> 애플리케이션을 협력하는 객체들의 공동체가 아닌 클래스로 구성된 설계도를 보는 관점은 유연하고 확장 가능한 애플리케이션의 구축을 방해한다.

> 훌륭한 객체지향 설계자가 되기 위해 거쳐야 할 첫 번째 도전은 코드를 담는 클래스의 관점에서  
> 메시지를 주고 받는 객체의 관점으로 사고의 중심을 전환하는 것이다.

> 중요한 것은 어떤 클래스가 필요한가가 아니라 어떤 객체들이 어떤 메시지를 주고받으며 협력하는가다.  
> 클래스는 객체들의 협력 관계를 코드로 옮기는 도구에 불과하다.

> 클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라.  
> 객체지향은 객체를 지향하는 것이지 클래스를 지향하는 것이 아니다.

## 02. 이상한 나라의 객체

```
객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다.  
객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다.
- 레베카 워프스브록(Rebecca Wirfs-Brock)
```

### 객체지향과 인지 능력

> 많은 사람들이 객체지향을 직관적이고 이해하기 쉬운 패러다임이라고 말하는 이유는  
> 객체지향이 세상을 자율적이고 독립적인 객체들로 분해할 수 있는 인간의 기본적인 인지능력에 기반을 두고 있기 때문이다.

> 객체지향 패러다임은 인간이 인지할 수 있는 다양한 객체들이 모여 현실 세계를 이루는 것처럼  
> 소프트웨어의 세계 역시 인간이 인지할 수 있는 다양한 소프트웨어 객체들이 모여 이뤄져 있다는 믿음에서 출발한다.  
> 하지만 유사성은 여기까지다.  
> 객체지향 패러다임의 목적은 현실 세계를 모방하는 것이 아니라 현실 세계를 기반으로 새로운 세계를 창조하는 것이다.

전등  
현실 세계: 사람의 손길 없이 스스로 껐다 켰다 하지 못한다.  
소프트웨어 세계: 스스로 껐다 켰다 할 수 있다.  

주문  
현실 세계: 사람이 직접 주문을 계산한다.  
소프트웨어 세계: 주문 객체가 직접 계산한다.  

### 객체, 그리고 소프트웨어 나라

> 객체의 다양한 특성을 효과적으로 설명하기 위해서는 객체를 상태(state), 행동(behavior), 식별자(identitty)를 지닌 실체로 보는 것이 가장 효과적이다.  
  
이 책에서는 객체를 다음과 같이 정의하기로 한다.  
```
객체란 식별 가능한 개체 또는 사물이다.  
객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다.  
객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다.  
소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.
```  
  
이 책에서는 객체의 상태를 다음과 같이 정의하기로 한다.
```
상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다.  
객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다.  
객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.
```
  
> 객체는 자율적인 존재라는 점을 명심하라.  
> 객체지향의 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수도 없다.  
> 스스로 자신의 상태를 책임져야 한다.  
> 외부의 객체가 직접적으로 객체의 상태를 주무를 수 없다면 간접적으로 객체의 상태를 변경하거나 조회할 수 있는 방법으로 행동을 정의한다.
  
이 책에서는 객체의 행동을 다음과 같이 정의하기로 한다.
```
행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다.  
행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다.  
객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다.
```
  
상태와 행동 사이에는 다음과 같은 관계가 있다.
- 객체의 행동은 상태에 영향을 받는다.
- 객체의 행동은 상태를 변경시킨다.

> 어떤 객체도 섬이 아니다.  
> 객체는 자신에게 주어진 책임을 완수하기 위해 다른 객체를 이용하고 다른 객체에게 서비스를 제공한다.
  
행동으로 인해 발생하는 결과는 두 가지 관점에서 설명할 수 있다.  
객체의 행동은 이 두 가지 관점의 부수효과를 명확하게 서술해야 한다.  
- 객체 자신의 상태 변경
- 행동 내에서 협력하는 다른 객체에 대한 메시지 전송

#### 상태 캡슐화

> 객체지향의 세계에서 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.  
> 앨리스 객체의 키를 작게 만드는 것이 앨리스 자신인 것처럼 음료 객체의 양을 줄이는 것은 음료 자신이어야 한다.  
> 따라서 앨리스는 직접 음료의 상태를 변경할 수 없다.  
> 단지 음료에게 자신이 음료를 마셨다는 메시지를 전달할 수 있을 뿐이다.  
> 적절한 정도로 양을 줄이는 것은 메시지를 전달받은 음료 스스로의 몫이다.

> 상태를 잘 정의된 행동 집합 뒤로 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.  
> 이것이 상태를 캡슐화해야 하는 이유다.

#### 식별자

```
식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다.  
값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야 한다.  
객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
```

객체  
- 참조 객체(reference object)
- 엔티티(entity)
- ex) Person 사람 클래스

값
- 값 객체 (value object)
- ex) Integer 숫자 클래스

#### 객체의 특성

- 객체는 상태를 가지며 상태는 변경 가능하다.
- 객체의 상태를 변경시키는 것은 객체의 행동이다.
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
  - 행동의 순서가 실행 결과에 영향을 미친다.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다.

### 기계로의 객체

> 객체의 상태를 조회하는 작업을 쿼리(query),  
> 객체의 상태를 변경하는 작업을 명령(command)

기계로 객체 설명  
> 사용자가 객체 기계의 버튼을 눌러 상태를 변경하거나 상태 조회를 요청하는 것은  
> 객체의 행동을 유발하기 위해 메시지를 전송하는 것과 유사하다.  
> 버튼을 누르는 것은 기계의 사용자지만 눌린 버튼에 따라 어떤 방식으로 동작할지는 기계 스스로 결정한다.  
> 이것은 전달된 메시지에 따라 스스로 판단하고 결정하는 자율적인 객체의 특성을 정확하게 묘사한다.

> 객체에 접근할 수 있는 유일한 방법은 객체가 제공하는 행동 뿐인걸 기계로 잘 표현한다.  
> 사용자는 객체가 제공하는 명령 버튼과 쿼리 버튼으로 구성된 인터페이스를 통해서만 객체에 접근할 수 있다.  
> 기계가 제공하는 버튼을 통해서만 상태에 접근할 수 있다는 점은 객체의 캡슐화를 강조한다.

### 행동이 상태를 결정한다.

> 객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라보는 것이다.  
> 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고 그 상태에 필요한 행동을 결정한다.  
> 애플리케이션 안에 살아갈 앨리스 객체를 설계할 때 초보자들은  
> 앨리스의 객체에게 필요한 상태가 무엇인지를 먼저 찾고, 키와 위치를 앨리스에 추가한다.  
> 그러고 나서야 키와 위치를 변경하거나 조회할 수 있는 행동이 무엇인지를 고민한다.  
> 안타깝게도 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.  

1. 상태를 먼저 결정할 경우 캡슐화가 저해된다.
   - 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출될 확률이 높아진다.
2. 객체를 협력자가 아닌 고립된 섬으로 만든다.
   - 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와 협력하기 위해서다.  
   - 불행히도 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 벗어난채 설계되어 협력에 적합하지 못한 객체를 창조하게 된다.
3. 객체의 재사용성이 저하된다.
   - 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하될 수 밖에 없다.

> 협력에 참여한느 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 상태가 아닌 행동에 초점을 맞추는 것이다.

### 의인화

현실 객체 vs 소프트웨어 객체

> 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다.  
> 소프트웨어 객체를 창조할 때 우리는 결코 현실 세계의 객체를 모방하지 않는다.  
> 오히려 소프트웨어 안에 창조하는 객체에게 현실 세계의 객체와는 전혀 다른 특징을 부여하는 것이 일반적이다.  
> 현실객체가 가지지 못한 추가적인 능력을 보유하는 것이 소프트웨어 객체다.

> 객체지향 설계자로서 우리의 목적은 현실을 모방하는 것이 아니다.  
> 단지 이상한 나라를 창조하기만 하면 된다.  
> 현실을 닮아야 한다는 어떤 제약이나 구속도 없다.  
> 여러분이 창조한 객체의 특성을 상기시킬 수 있다면 현실 속의 객체의 이름을 이용해 객체를 묘사하라.  
> 그렇지 않다면 깔끔하게 현실을 무시하고 자유롭게 여러분만의 새로운 세계를 창조하길 바란다.


## 03. 타입과 추상화

### 추상화를 통한 복잡성 극복

> 현실은 복잡하며 예측 불가능한 혼돈의 덩어리다.  
> 기존에 현실을 반영한 지형이 표시된 지하철 노선도는 사용자에게 불필요한 정보를 제공하고 있었다.  
> 문제는 복잡성의 총체인 현실이라는 괴물을 그대로 수용하기에는 인간이 지니고 있는 인지 능력과 저장 공간이 너무나도 보잘것없다는 점이다.  
> 따라서 사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단수화하는 전략을 따른다.  
> 해리 백의 지하철 노선도는 불필요한 지형 정보를 제거함으로써 단순함을 달성한 추상화의 훌률한 예이다.  
> 따라서 진정한 의미에서 추상화란 현실에서 출발하되  
> 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정이라고 할 수 있다.

> 어떤 추상화도 의도된 목적이 아닌 다른 목적으로 사용된다면 오도될 수 있다.  
> 추상화의 수준, 이익, 가치는 **목적에 의존적**이다.  
> 리처드 파인만의 말처럼 "현상은 복잡하다. 법칙은 단순하다. 버릴 게 무엇인지 알라내라."

이 책에서는 추상화를 다음과 같의 정의한다.  
```
어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.  
복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다.  
- 첫 번째 차원은 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
- 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.
  
모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화하는 것이라는 점을 기억하라.
```

### 객체지향과 추상화

> 앨리스는 정원사들, 병사들, 왖아와 공주, 하객으로 참석한 왕과 왕비들, 하트 왕과 하트 여왕의 차이점은  
> 과감하게 무시한 채 공통점만을 취해 단순화해 버렸다.  
> "기껏해야 트럼프에 불과해"라고 읊조리는 마지막 대사에서 앨리스는 정원에 서 있는 다양한  
> 인물들을 계급, 나이, 성격 등의 차이점은 무시한 채 '트럼프'라는 유사성을 기반으로 추상화해서 바라보고 있다.

#### 개념

> 공통점을 기반으로 객체들을 묶기 위한 그릇을 **개념(conecpt)**이라고 한다.  
> 개념이란 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 뜻한다.

> 개념을 이용하면 객체를 여러 그룹으로 **분류(classification)**할 수 있다.  
> 정원에 존재하는 객체를 '트럼프'와 '토끼'라는 두 개의 개념으로 나누고는 두 개념에 적합한 객체가  
> 각 그룹에 포함되도록 분류했다는 사실에 주목하라.  
> 결과적으로 개념은 공통점을 기반으로 객체를 분류할 수 있는 일종의 체라고 할 수 있다.  

> 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때 객체를 그 개념의 **인스턴스(instance)**라고 한다. 따라서 객체를 다음과 같이 정의할 수도 있다.  
```
객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다.  
개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.
```

#### 개념의 세 가지 관점

심볼(symbol): 개념을 가리키는 간략한 이름이나 명칭  
내연(intension): 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.  
외연(extension): 개념에 속하는 모든 객체의 집합(set)  
  
이상항 나라의 앨리스를 통해 분류하면?  
심볼: 트럼프  
내연: 몸이 납작하고 두 손과 두 발은 네모 귀퉁이에 달려 있는 등장인물  
외연: 정원사, 병사, 신하, 왕자와 공주, 하객으로 참석한 왕과 왕비들, 하트 잭, 하트 왕과 하트 여왕

### 타입

#### 타입은 개념이다.  

> 공학자들은 개념을 대체할 수 있는 좀 더 세련돼 보이는 용어를 수학으로부터 차용해 왔다.  
> 그것은 바로 **타입(type)**이다.

> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는  
> 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고한다.  
> 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

#### 데이터 타입

이 책에서는 프로그래밍 언어 관점에서 데이터 타입을 다음과 같이 정의한다.  
```
데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다.  
데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.
```

#### 행동이 우선이다.

> 동일한 행동이란 동일한 책임을 의미하며, 동일한 책임이란 동일한 메시지 수신을 의미한다.  
> 따라서 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다.  
> 다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수밖에 없다.  
> 이것은 **다형성**에 의미를 부여한다.
  
> 데이터의 내부 표현 방식과 무관하게 행동만이 고려 대상이라는 사실은 외부에 데이터를 감춰야 한다는 것을 의미한다.  
> 따라서 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다.  
> 이 원칙을 흔히 **캡슐화**라고 한다.
  
> 객체를 결정하는 것은 행동이다.  
> 데이터는 단지 행동을 따를 뿐이다.  
> 이것이 객체를 객체답게 만드는 가장 핵심적인 원칙이다.

### 타입의 계층

#### 일반화/특수화 관계

> 일반화/특수화는 행동에 관한 것이다.  
> 일반적인 타입은 특수한 타입에 비해 더 적은 수의 행동을 가지며 특수한 타입은 일반적인 타입에 비해 더 많은 행동을 가진다.  
> 단, 특수한 타입은 일반적인 타입이 할 수 있는 모든 행동을 동일하게 수행할 수 있어야 한다.
  
일반화: 트럼프  
- 납작 엎드릴 수 있다.
- 뒤집어질 수 있다.

특수화: 트럼프 인간  
- 납작 엎드릴 수 있다.
- 뒤집어질 수 있다.
- 걸을 수 있다.

#### 슈퍼타입과 서브타입

> 일반적인 타입을 슈퍼타입, 특수한 타입을 서브타입이라 한다.  

> 슈퍼타입과 서브타입에서 중요한 것은 두 타입 간의 관계가 행동에 의해 결정된다는 점이다.  
> 즉, 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행위적 호환성을 만족시켜야 한다.

### 정적 모델

#### 타입의 목적

> 타입을 사용하면 동적으로 변하는 객체의 상태를 정적인 관점에서 표현할 수 있다.  
> 앨리스의 키인 상태는 시간에 따라 계속 변하지만, 무관하게 정적인 모습으로 볼 수 있게 해주는 게 타입이다.  

#### 타입은 추상화다.

> 타입을 이용하면 객체의 동적인 특성을 추상화할 수 있다.  
> 결국 타입은 시간에 따른 객체의 상태 변경이라는 복잡성을 단순화할 수 있는 효과적인 방법인 것이다.

#### 동적 모델과 정적 모델

> 객체지향 애플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과  
> 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야 한다.  
> 동적 모델과 정적 모델의 구분은 실제로 프로그래밍이라는 행위와도 관련이 깊다.  
> 여러분이 객체지향 프로그래밍 언어를 이용해 클래스를 작성하는 시점에는 시스템을 정적인 관점에서 접근하는 것이다.  
> 그러나 실제로 애플리케이션을 실행해 객체의 상태 변경을 추적하고 디버깅하는 동안에는 객체의 동적인 모델을 탐험하고 있는 것이다.  

#### 클래스

> 객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현된다.  
> 따라서 타입을 구현하는 가장 보편적인 방법은 클래스를 이용하는 것이다.  
> '타입을 구현한다'라고 표현했음을 주목하라. 클래스와 타입은 동일한 것이 아니다.  
> 타입은 객체를 분류하기 위해 사용하는 개념이다. 반면 클래스는 단지 타입을 구현할 수 있는 여러 구현 메커니즘 중 하나일 뿐이다.

> 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 행동이라는 사실만을 기억하길 바란다.  
> 객체를 분류하기 위해 타입을 결정한 후 프로그래밍 언어를 이용해 타입을 구현할 수 있는 한 가지 방법이 클래스라는 사실을 아는 것만으로도 충분하다.  

> 결국 객체지향에서 중요한 것은 동적으로 변하는 객체의 '상태'와 상태를 변경하는 '행위'다.  
> 클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘이라는 사실을 기억하라.

## 04. 역할, 책임, 협력

### 협력

> 협력은 한 사람이 다른 사람에게 도움을 **요청**할 때 시작된다.  

#### 재판 속 협력

- 누군가가 왕에게 재판을 **요청**함으로써 재판이 시작된다.  
- 왕이 하얀 토끼에게 증인을 부를 것을 **요청**한다.  
- 왕의 요청을 받은 토끼는 모자 장수에게 증인석으로 입장할 것을 **요청**한다.  
- 모자 장수는 증인석에 입장함으로써 토끼의 요청에 **응답**한다.
- 모자 장수의 입장은 왕이 토끼에게 요청했던 증인 호출에 대한 **응답**이기도 하다.  
- 이제 왕은 모자 장수에게 증언할 것을 **요청**한다.  
- 모자 장수는 자신이 알고 있는 내용을 증언함으로써 왕의 요청에 **응답**한다.  

> 결국 어떤 등장인물들이 특정한 요청을 받아들일 수 있는 이유는 그 요청에 대해 적절한 방식으로  
> 응답하는 데 필요한 지식과 행동 방식을 가지고 있기 때문이다.  
> 그리고 요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.  

### 책임

> 어떤 대상에 대한 요청은 그 대상이 요청을 처리할 책임이 있음을 암시한다.  

#### 책임의 분류  

> 객체의 책임은 '객체가 무엇을 알고 있는가(knowing)'와 '무엇을 할 수 있는가(doing)'로 구성된다.  

- 하는 것(doing)
  - 객체를 생성하거나 계산을 하는 등의 스스로 하는 것
  - 다른 객체의 행동을 시작시키는 것
  - 다른 객체의 활동을 제어하고 조절하는 것
- 아는 것(knowing)
  - 개인적인 정보에 관해 아는 것
  - 관련된 객체에 관해 아는 것
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
  
- 왕은 재판 집행이라는 책임을 수행하기 위해 먼저 하얀 토끼에게 목격자를 불러오도록 요청한 후 목격자인 모자 장수에게 증언을 하라고 요청한다. 이 경우 왕은 재판에 참여하는 "다른 객체들의 활동을 제어하고 조율"하고 있다. 따라서 왕은 하는 것과 관련되 책임을 수행한다.
- 하얀 토끼는 목격자가 모자 장수라는 사실을 알고 있으며, 동시에 모자 장수가 증인석에 입장하도록 요청한다. 첫 번째 책임은 "관련된 객체에 대해 아는 것"에 해당하고 두 번째 책임은 "다른 객체의 행동을 시작시키는 것"에 해당한다. 따라서 하얀 토끼는 아는 것과 하는 것의 두 가지 종류의 책임을 모두 수행하고 있다.  
- 모자 장수의 경우 스스로 증인석에 입장해야 하는 책임과 자신이 알고 있는 사실을 증언해야 할 책임을 가지고 있다. 첫 번째 책임은 "객체를 생성하거나 계산을 하는 등의 스스로 하는 것"의 범주에 해당하고 두 번째 책임은 "자신이 유도하거나 계산할 수 있는 것에 관해 아는 것"에 해당한다는 것을 알수 있다. 따라서 모자 장수 역시 재판이라는 협력 안에서 아는 것과 하는 것의 두 가지 종류의 책ㅇ미을 모두 수행하고 있다.

> 즉 책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것의 측면)와 외부에 저공해 줄 수 있는 서비스(하는 것의 측면)의 목록이다.  
> 따라서 책임은 객체의 **공영 인터페이스(public interface)**를 구성한다.  
> 공용 인터페이스의 개념은 뒤에서 다룰 객체지향의 중요한 원리 중 하나인 캡슐화로 이어진다.

#### 책임과 메시지

> 한 객체가 다른 객체에게 전송한 요청은 그 요청을 수신한 객체의 책임이 수행되게 한다.  
> 이처럼 객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 **메시지 전송(message-send)**이라고 한다.  
  
> 책임과 메시지의 수준이 같지는 않다는 점이다.  
> 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것이다.  
> 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적이다.  

> 설계를 시작하는 초반에는 어떤 객체가 어떤 책임을 가지고 어떤 방식으로 서로 협력해야 하는지에 대해  
> 개요를 아는 것만으로도 충분하다. 책임과 협력의 구조가 자리를 잡기 전까지는 책임을 구현하는 방법에  
> 대한 고민은 잠시 뒤로 미루는 것이 좋다. 물론 언젠가는 모자 장수가 어떻게 증언할 것인지를  
> 고민해야 하겟지만 재판이라는 협력에 참여하기 위해 왕과 모자 장수가 상호 협력해야 하고,  
> 이를 위해 '증언하라'라는 메시지를 송신하고 수신할 수 있다는 것을 결정하는 것이 더 중요하다.

> 객체지향 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터  
> 메시지를 수신할 것인지를 결정하는 것으로부터 시작된다. 어떤 클래스가 필요하고 어떤 메서드를  
> 포함해야 하는지를 결정하는 것은 책임과 메시지에 대한 대략적인 윤곽을 잡은 후에 시작해도 늦지 않다.  
  
### 역할

#### 책임의 집합이 의미하는 것

> 모자 장수가 재판이라는 협력 안에서 '증인석에 입장한다'와 '증언한다'라는 책임을 가진다는 것은 무엇을 의미하는가?  
> 왕이 '재판한다'는 책임을 지고 하얀 토끼에게 목격자를 불러오도록 요청한 후 증언하도록 요구한다는 것은 무엇을 의미하는가?  
> 그것은 재판이라는 협력에 참여하기 위해 모자 장수는 '증인'이라는 역할을 수행하고 있고,  
> 왕은 '판사'라는 역할을 수행하고 있음을 의미한다.  
  
> 결론적으로 어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시한다.  
> 이것이 중요한가? 왕은 왕일 뿐이고 모자 장수는 모자 장수일 뿐이지 않는가?  
> 굳이 왕을 판사라고 부르고 모자 장수를 증인이라고 불러서 상황을 복잡하게 만드는 이유는 무엇인가?  
  
> 그것은 역할이 재사용 가능하고 유연한 객체지향 설계를 낳는 매우 중요한 구성요소이기 때문이다.

#### 역할이 답이다

> 재판이라는 협력 과정 속에서 하트 왕과 하트 여왕은 '판사'의 역할을 수행한다.  
> 모자 장수와 요리사, 그리고 앨리스는 '증인'의 역할을 수행한다.  
> 따라서 '판사'와 '증인'이라는 **역할(role)**을 사용하면 세 가지 협력을 모두 포괄할 수 있는 하나의 협력으로 추상화할 수 있다.  

  
> 역할은 협력 내에서 다른 객체로 대체할 수 있음을 나타내는 일종의 표식이다.  
> 협력 안에서 역할은 "이 자리는 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있습니다."라고 말하는 것과 같다.  

> 그렇다면 어떤 객체라도 '판사'나 '증인'의 역할을 대체할 수 있을까?  
> 물론 그렇지는 않다. 역할을 대체하기 위해서는 각 역할이 수신할 수 있는 메시지를 동일한 방식으로 이해해야 한다.  
> 하트 왕이 '판사'의 역할을 수행할 수 있는 이유는 '판사'가 수신할 수 있는 '재판하라'라는 메시지를 동일하게 이해하고 처리할 수 있기 때문이다.  
> 모자 장수를 '증인'이라고 부를 수 있는 이유 역시 '증인석에 입장하라'와 '증언하라'라는 메시지를 이해할 수 있기 때문이다.  
> 따라서 역할을 대체할 수 있는 객체는 동일한 메시지를 이해할 수 있는 객체로 한정된다.  

  
> 앞에서 메시지가 책임을 의미한다고 했던 것을 기억하라.  
> 결국 동일한 역할을 수행할 수 있다는 것은 해당 객체들이 협력 내에서 동일한 책임의 집합을 수행할 수 있다는 것을 의미한다.  

  
요약  
> 역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부화를 줄일 수 있다.  
> 역할은 객체지향 설계의 **단순성(simplicity)**, **유연성(flexibility)**, **재사용성(reusability)**을 뒷받침하는 핵심 개념이다.  

  
#### 협력의 추상화

> 왕 - 하얀 토끼 - 모자 장수  
> 왕 - 하얀 토끼 요리사  
> 여왕 - 하얀 토끼 - 앨리스  
> 의 협력은 모두 동일한 순서에 따라 메시지를 주고받으며 상호작용한다.  
> 따라서 구체적인 객체를 추상적인 역할로 대체함으로써  
> 판사 - 하얀 토끼 - 증인  
> 위와 같은 식으로 하나의 추상적인 협력으로 대체할 수 있다.  
  
#### 대체 가능성

1. 객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다는 점에 주목하라.
2. 객체가 역할에 주어진 책임 이외에 다른 책임을 수행할 수도 있다는 사실에 주목하라.
3. 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있다.
  
> 역할이 협력을 추상적으로 만들 수 있는 이유는 역할 자체가 객체의 추상화이기 때문이다.

요약  
> 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미한다.  

### 객체의 모양을 결정하는 협력

#### 흔한 오류

1. 시스템에 필요한 데이터를 저장하기 위해 객체가 존재한다.
   1. 데이터는 단지 객체가 행위를 수행하는 데 필요한 재료일 뿐이다.
   2. 객체가 존재하는 이유는 행위를 수행하며 협력에 참여하기 위해서다.
   3. 실제로 중요한 건 객체의 행동, 즉 책임이다.
2. 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다.
   1. 정적인 클래스가 아닌 협력에 참여하는 동적인 객체
   2. 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위해 프로그래밍 언어가 제공하는 구현 메커니즘
   3. 클래스를 어떻게 구현할 것인가가 아니라 객체가 협력 안에서 어떤 책임과 역할을 수행할 것인지를 결정하는 것이 객체지향의 핵심!
  
#### 협력을 따라 흐르는 객체의 책임

> 앨리스의 이야기에서 누군가는 재판을 진행해야 하고 누군가는 증인을 증인석으로 불러야 하며 누군가는 증언해야 한다.  
> 이처럼 협력을 구성하는 데 필요한 일련의 책임을 먼저 고안하고 나면 그 책임을 수행하는 데 필요한 객체를 선택하게 된다.  
> 어떤 책임은 왕에게, 하얀 토끼에게, 모자 장수에게 각각 할당하면서 책임을 각 객체에게 할당해 나간다.  
> 그리고 이렇게 할당된 책임은 왕과 하얀 토끼, 모자 장수라는 객체들이 외부에 제공하게 될 행동을 정의하게 된다.  
> 이제 행동이 결정됐으니 각 객체가 필요로 하는 데이터를 정의할 수 있다.  
> 그리고 이렇게 데이터와 행동이 결정된 후에야 왕과 하얀 토끼, 모자 장수를 구현하는 클래스를 개발할 수 있을 것이다.

> 객체의 행위에 초점을 맞추기 위해서는 협력이라는 실행 문맥 안에서 책임을 분배해야 한다.  
> 각 객체가 가져야 하는 상태와 행위에 대해 고민하기 전에 그 객체가 참여할 문맥인 협력을 정의하라.  
> 객체지향 시스템에서 가장 중요한 것은 충분히 자율적인 동시에 충분히 협력적인 객체를 창조하는 것이다.  
> 이 목표를 달성할 수 있는 가장 쉬운 방법은 객체를 충분히 협력적으로 만든 후에 협력이라는 문맥 안에서  
> 객체를 충분히 자율적으로 만드는 것이다.  

  
### 객체지향 설계 기법

1. 책임-주도 설계(Responsibility-Driven Design)
2. 디자인 패턴(Design Pattern)
3. 테스트-주도 개발(Test-Driven Development)

#### 책임-주도 설계

- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

#### 디자인 패턴

> 책임-주도 설계는 객체의 역할, 책임, 협력을 고안하기 위한 방법과 절차를 제시한다.  
> 반면 디자인 패턴은 책임-주도 설계의 결과를 표현한다.
  
앨리스터 코오번
> 효과적으로 일하는 사람들의 한 가지 특징은 아무것도 없는 상태에서 작업하지 않고,  
> 이전에 훌륭한 결과물을 모방하고 약간의 수정을 거쳐 원하는 결과물을 만들어 낸다.  

  
> 디자인 패턴은 공통으로 사용할 수 있는 책임, 역할, 협력의 템플릿이다.  
> 만약 특정한 상황에 적용 가능한 디자인 패턴을 잘 알고 있다면 책임-주도 설계의 절차를 순차적으로  
> 따르지 않고도 시스템 안에 구현할 객체들의 역할과 책임, 협력 관계를 빠르고 손쉽게 포착할 수 있을 것이다.  
> 디자인 패턴은 책임-주도 설계의 결과물인 동시에 지름길이다.

#### 테스트-주도 개발

> 테스트-주도 개발은 책임-주도 설계의 기본 개념을 따른다.  

> 테스트-주도 개발은 객체지향에 대한 깊이 있는 지식을 요구한다.  
> 테스트를 작성하기 위해 객체의 메서드를 호출하고 반환 값을 검증하는 것은 순간적으로 객체가  
> 수행해야 하는 책임에 관해 생각한 것이다.  
> 테스트-주도 개발은 책임-주도 설계의 기본 개념과 다양한 원칙과 프랙티스, 패턴을 종합적으로 이해하고 좋은 설계에 대한 감각과 경험을 길러야만 적용할 수 있는 설계기법이다.  
> 역할, 책임, 협력에 집중하고 객체지향의 원칙을 적용하려는 깊이 있는 고민과 노력을 통해서만 테스트-주도 개발의 해택을 누릴 수 있따.


## 05. 책임과 메시지

> 의도는 "메시징"이다. 훌륭하고 성정 가능한 시스템을 만들기 위한 핵심은  
> 모듈 내부의 속성과 행동이 어떤가보다는 모듈이 어떻게 커뮤니케이션하는가에 달려있다.

### 메시지와 메서드

#### 메시지

> 왕이 모자 장수에게 전송하는 메시지를 가리키는 '증언하라'라는 부분을 **메시지 이름**이라고 한다.  
> 메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 **인자**를 통해 추가 정보를 제공할 수 있다.  

- 증언하라(어제, 왕국)

> 메시지 전송은 결국 수신자와 메시지의 조합이다.  
> 왕은 메시지를 누구에게 전송해야 하는지를 알아야 한다.  

- 모자장수.증언하라(어제, 왕국)

#### 메서드

> 모자 장수가 메시지를 처리하기 위해 내부적으로 선택하는 방법을 **메서드**라고 한다.

> 객체지향 프로그래밍에서 행동은 수행할 책임을 지닌 객체에게 전송된 메시지에 의해 시작된다.  
> 메시지는 행동에 대한 요청을 표현하고, 요청을 수행하는 데 필요한 추가적인 정보를 인자를 통해 전달한다.  
> 수신자는 메시지를 수신하는 객체를 가리킨다. 수신자가 메시지를 받아들인다는 것은 해당 행동을  
> 수행할 책임을 받아들인다는 것을 의미한다. 객체는 메시지에 대한 응답으로 요청을 만족하기 위한 어떤 메서드를 수행할 것이다.

#### 다형성

> 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 **대체 가능성**을 의미한다.  
> 메시지를 수신하는 대상이 모자 장수인지, 요리사인지, 앨리스인지 알 필요 없다.  
> 단 '증언하라'라는 메시지를 이해하면서 '증인'역할을 수행할 수 있는 수신자라면 어떤 누구와도 협력이 가능하다.  
> 따라서 왕에게 영향을 주지 않고도 메시지를 수신할 객체의 타입을 자유롭게 추가할 수 있다.  

> 객체지향 용어를 이용해 표현하자면 다형성은 송신자와 수신자 간의 객체 타입에 대한  
> 결합도를 메시지에 대한 결합도로 낮춤으로써 달성된다.

#### 유연하고 확장 가능하고 재사용성이 높은 협력의 의미

> 송신자가 수신자에 대해 매우 적은 정보만 알고 있더라도 상호 협력이 가능하다는 사실은 설계의 품질에 큰 영향을 미친다.

- 협력이 유연해진다.
- 협력이 수행되는 방식을 확장할 수 있다.
- 협력이 수행되는 방식을 재사용할 수 있다.

### 책임의 자율성이 협력의 품질을 결정한다.

1. 자율적인 책임은 협력을 단순하게 만든다.

> 왕이 원하는 것은 단순히 '증언'하는 것 뿐이다.  
> 증언하기 위해 모자 장수가 어떤 식으로 생각하고 어떤 순서대로 행동하는지에 대해 왕은 관심이 없다.  
> 자율적인 책임은 세부적인 사항들을 무시하고 의도를 드러내는 하나의 문장으로 표현함으로써 협력을 단수낳게 만든다.  
> 객체지향 커뮤니티의 전문 용어로 표현하자면 책임이 적절하게 추상화된다.

2. 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다.

> 왕은 모자 장수가 외부에 노출한 책임은 볼 수 있지만 모자 장수가 내부적으로 어떻게 책임을 수행하는지는 볼 수 없다.  
> 모자 장수는 협력에 참여하기 위해 외부에 노출하는 부분과 책임을 수행하기 위해 내부적으로 선택하는 방법을 명확하게 나눈다.  
> 객체지향 커뮤니티의 전문 용어로 표현하자면 요청하는 객체가 몰라도 되는 사적인 부분이 객체 내부로  
> **캡슐화**되기 때문에 **인터페이스**와 구현이 불리된다.  
> 외부와 내부의 분리는 훌륭한 객체지향 설계를 그렇지 못한 설계와 분리하는 가장 중요한 기반이다.  

3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않는다.

> 책임이 자율적일수록 변경에 의해 수정돼야 하는 범위가 좁아지고 명확해진다.  
> 객체지향 커뮤니티의 전문 용어로 표현하자면 변경의 파급효과가 객체 내부로 **캡슐화**되기 때문에 두 객체 간의 **결합도**가 낮아진다.

4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공한다.

> '증언하라'라는 책임만 수행할 수 있다면 모자 장수가 아닌 앨리스, 요리사여도 문제가 없다.  
> 책임이 자율적일수록 협력이 좀 더 유연해지고 다양한 문맥에서 재활용될 수 있다.  
> 객체지향 커뮤니티의 전문 용어로 표현하자면 설계가 **유연**해지고 **재사용성**이 높아진다.

5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워진다.  

> '증인석에 입장하다'와 '증언하다'라는 두 가지 책임은 협력 안에서 모자 장수가 자신의 의지를 기반으로 완수할  
> 수 있을 정도로 충분히 자율적이다. 두 책임으로 모자 장수가 수행해야하는 역할을 명확하게 전달한다.  
> 바로 '증인'이라는 역할을 수행한다는 사실이다.  

> 객체가 수행하는 책임들이 자율적이면 자율적일수록 객체의 존재 이유를 명확하게 표현할 수 있다.  
> 객체는 동일한 목적을 달성하는 강하게 연관된 책임으로 구성되기 떄문이다.  
> 객체지향 커뮤니티의 전문 용어로 표현하자면 책임이 자율적일수록 객체의 **응집도**를 높은 상태로 유지하기 쉬워진다.  

> 책임이 자율적일수록 협력이 이해하기 쉬워지고, 객체의 외부와 내부의 구분이 명확해지며,  
> 변경에 의한 파급효과를 제한할 수 있고, 유연하게 변경할 수 있는 동시에 다양한 문맥에서 재활용할 수 있게 된다.  

> 책임이 자율적일수록 적절하게 '추상화'되며, '응집도'가 높아지고, '결합도'가 낮아지며, '캡슐화'가 증진되고,  
> '인터페이스와 구현이 명확하게 분리'되며, 설계의 '유연성'과 '재사용성'이 향상된다.  
> 처음에는 이런 용어들이 낯설고 이해하기도 어렵겠지만 이런 특성들이 모여 객체지향을 다른 패러다임보다 우월하게 만든다는 사실을 이해하는 것이 매우 중요하다.

> 객체지향의 강력함을 누리기 위한 출발점은 책임을 자율적으로 만드는 것이다.  
> 그리고 이것은 여러분이 선택하는 메시지에 따라 달라지낟.  
> 이 사실을 여러분의 머릿속 어딘가에 꼭꼭 넣어두기 바란다.

